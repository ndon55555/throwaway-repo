{"version":3,"file":"browser.js","sources":["../../../../src/jsMain/kotlin/generated/gen-consumer-tags-js.kt","../../../../src/commonMain/kotlin/api.kt","../../../../src/commonMain/kotlin/generated/gen-tag-unions.kt","../../../classes/kotlin/js/main/generated/_Collections.kt","../../../../src/js/Main.kt","../../../classes/kotlin/js/main/util/Standard.kt","../../../classes/kotlin/js/main/kotlin/text/string.kt","../../../../src/js/view/TetrisWeb.kt"],"sourcesContent":["package kotlinx.html.js\r\n\r\nimport kotlinx.html.*\r\nimport kotlinx.html.impl.*\r\nimport kotlinx.html.attributes.*\r\nimport org.w3c.dom.*\r\n\r\n/*******************************************************************************\r\n    DO NOT EDIT\r\n    This file was generated by module generate\r\n*******************************************************************************/\r\n\r\n/**\r\n * Anchor\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.a(href : String? = null, target : String? = null, classes : String? = null, crossinline block : A.() -> Unit = {}) : HTMLAnchorElement = A(attributesMapOf(\"href\", href,\"target\", target,\"class\", classes), this).visitAndFinalize(this, block) as HTMLAnchorElement\r\n\r\n/**\r\n * Abbreviated form (e.g., WWW, HTTP,etc.)\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.abbr(classes : String? = null, crossinline block : ABBR.() -> Unit = {}) : HTMLElement = ABBR(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\r\n\r\n/**\r\n * Information on author\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.address(classes : String? = null, crossinline block : ADDRESS.() -> Unit = {}) : HTMLElement = ADDRESS(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\r\n\r\n/**\r\n * Client-side image map area\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.area(shape : AreaShape? = null, alt : String? = null, classes : String? = null, crossinline block : AREA.() -> Unit = {}) : HTMLAreaElement = AREA(attributesMapOf(\"Shape\", shape?.enumEncode(),\"alt\", alt,\"class\", classes), this).visitAndFinalize(this, block) as HTMLAreaElement\r\n\r\n/**\r\n * Self-contained syndicatable or reusable composition\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.article(classes : String? = null, crossinline block : ARTICLE.() -> Unit = {}) : HTMLElement = ARTICLE(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\r\n\r\n/**\r\n * Sidebar for tangentially related content\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.aside(classes : String? = null, crossinline block : ASIDE.() -> Unit = {}) : HTMLElement = ASIDE(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\r\n\r\n/**\r\n * Audio player\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.audio(classes : String? = null, crossinline block : AUDIO.() -> Unit = {}) : HTMLAudioElement = AUDIO(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block) as HTMLAudioElement\r\n\r\n/**\r\n * Bold text style\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.b(classes : String? = null, crossinline block : B.() -> Unit = {}) : HTMLElement = B(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\r\n\r\n/**\r\n * Document base URI\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.base(classes : String? = null, crossinline block : BASE.() -> Unit = {}) : HTMLBaseElement = BASE(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block) as HTMLBaseElement\r\n\r\n/**\r\n * Text directionality isolation\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.bdi(classes : String? = null, crossinline block : BDI.() -> Unit = {}) : HTMLElement = BDI(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\r\n\r\n/**\r\n * I18N BiDi over-ride\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.bdo(classes : String? = null, crossinline block : BDO.() -> Unit = {}) : HTMLElement = BDO(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\r\n\r\n/**\r\n * Long quotation\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.blockQuote(classes : String? = null, crossinline block : BLOCKQUOTE.() -> Unit = {}) : HTMLElement = BLOCKQUOTE(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\r\n\r\n/**\r\n * Document body\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.body(classes : String? = null, crossinline block : BODY.() -> Unit = {}) : HTMLBodyElement = BODY(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block) as HTMLBodyElement\r\n\r\n/**\r\n * Forced line break\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.br(classes : String? = null, crossinline block : BR.() -> Unit = {}) : HTMLBRElement = BR(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block) as HTMLBRElement\r\n\r\n/**\r\n * Push button\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.button(formEncType : ButtonFormEncType? = null, formMethod : ButtonFormMethod? = null, name : String? = null, type : ButtonType? = null, classes : String? = null, crossinline block : BUTTON.() -> Unit = {}) : HTMLButtonElement = BUTTON(attributesMapOf(\"formenctype\", formEncType?.enumEncode(),\"formmethod\", formMethod?.enumEncode(),\"name\", name,\"type\", type?.enumEncode(),\"class\", classes), this).visitAndFinalize(this, block) as HTMLButtonElement\r\n\r\n/**\r\n * Scriptable bitmap canvas\r\n */\r\n@HtmlTagMarker\r\npublic fun TagConsumer<HTMLElement>.canvas(classes : String? = null, content : String = \"\") : HTMLCanvasElement = CANVAS(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, {+content}) as HTMLCanvasElement\r\n/**\r\n * Scriptable bitmap canvas\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.canvas(classes : String? = null, crossinline block : CANVAS.() -> Unit = {}) : HTMLCanvasElement = CANVAS(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block) as HTMLCanvasElement\r\n\r\n/**\r\n * Table caption\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.caption(classes : String? = null, crossinline block : CAPTION.() -> Unit = {}) : HTMLElement = CAPTION(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\r\n\r\n/**\r\n * Citation\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.cite(classes : String? = null, crossinline block : CITE.() -> Unit = {}) : HTMLElement = CITE(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\r\n\r\n/**\r\n * Computer code fragment\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.code(classes : String? = null, crossinline block : CODE.() -> Unit = {}) : HTMLElement = CODE(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\r\n\r\n/**\r\n * Table column\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.col(classes : String? = null, crossinline block : COL.() -> Unit = {}) : HTMLTableColElement = COL(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block) as HTMLTableColElement\r\n\r\n/**\r\n * Table column group\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.colGroup(classes : String? = null, crossinline block : COLGROUP.() -> Unit = {}) : HTMLTableColElement = COLGROUP(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block) as HTMLTableColElement\r\n\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.command(type : CommandType? = null, classes : String? = null, crossinline block : COMMAND.() -> Unit = {}) : HTMLElement = COMMAND(attributesMapOf(\"type\", type?.enumEncode(),\"class\", classes), this).visitAndFinalize(this, block)\r\n\r\n/**\r\n * Container for options for \r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.dataList(classes : String? = null, crossinline block : DATALIST.() -> Unit = {}) : HTMLDataListElement = DATALIST(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block) as HTMLDataListElement\r\n\r\n/**\r\n * Definition description\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.dd(classes : String? = null, crossinline block : DD.() -> Unit = {}) : HTMLElement = DD(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\r\n\r\n/**\r\n * Deleted text\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.del(classes : String? = null, crossinline block : DEL.() -> Unit = {}) : HTMLElement = DEL(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\r\n\r\n/**\r\n * Disclosure control for hiding details\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.details(classes : String? = null, crossinline block : DETAILS.() -> Unit = {}) : HTMLDetailsElement = DETAILS(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block) as HTMLDetailsElement\r\n\r\n/**\r\n * Instance definition\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.dfn(classes : String? = null, crossinline block : DFN.() -> Unit = {}) : HTMLElement = DFN(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\r\n\r\n/**\r\n * Dialog box or window\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.dialog(classes : String? = null, crossinline block : DIALOG.() -> Unit = {}) : HTMLDialogElement = DIALOG(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block) as HTMLDialogElement\r\n\r\n/**\r\n * Generic language/style container\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.div(classes : String? = null, crossinline block : DIV.() -> Unit = {}) : HTMLDivElement = DIV(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block) as HTMLDivElement\r\n\r\n/**\r\n * Definition list\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.dl(classes : String? = null, crossinline block : DL.() -> Unit = {}) : HTMLElement = DL(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\r\n\r\n/**\r\n * Definition term\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.dt(classes : String? = null, crossinline block : DT.() -> Unit = {}) : HTMLElement = DT(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\r\n\r\n/**\r\n * Emphasis\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.em(classes : String? = null, crossinline block : EM.() -> Unit = {}) : HTMLElement = EM(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\r\n\r\n/**\r\n * Plugin\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.embed(classes : String? = null, crossinline block : EMBED.() -> Unit = {}) : HTMLEmbedElement = EMBED(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block) as HTMLEmbedElement\r\n\r\n/**\r\n * Form control group\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.fieldSet(classes : String? = null, crossinline block : FIELDSET.() -> Unit = {}) : HTMLFieldSetElement = FIELDSET(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block) as HTMLFieldSetElement\r\n\r\n/**\r\n * Caption for \r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.figcaption(classes : String? = null, crossinline block : FIGCAPTION.() -> Unit = {}) : HTMLElement = FIGCAPTION(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\r\n\r\n/**\r\n * Figure with optional caption\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.figure(classes : String? = null, crossinline block : FIGURE.() -> Unit = {}) : HTMLElement = FIGURE(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\r\n\r\n/**\r\n * Footer for a page or section\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.footer(classes : String? = null, crossinline block : FOOTER.() -> Unit = {}) : HTMLElement = FOOTER(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\r\n\r\n/**\r\n * Interactive form\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.form(action : String? = null, encType : FormEncType? = null, method : FormMethod? = null, classes : String? = null, crossinline block : FORM.() -> Unit = {}) : HTMLFormElement = FORM(attributesMapOf(\"action\", action,\"enctype\", encType?.enumEncode(),\"method\", method?.enumEncode(),\"class\", classes), this).visitAndFinalize(this, block) as HTMLFormElement\r\n\r\n/**\r\n * Heading\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.h1(classes : String? = null, crossinline block : H1.() -> Unit = {}) : HTMLHeadingElement = H1(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block) as HTMLHeadingElement\r\n\r\n/**\r\n * Heading\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.h2(classes : String? = null, crossinline block : H2.() -> Unit = {}) : HTMLHeadingElement = H2(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block) as HTMLHeadingElement\r\n\r\n/**\r\n * Heading\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.h3(classes : String? = null, crossinline block : H3.() -> Unit = {}) : HTMLHeadingElement = H3(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block) as HTMLHeadingElement\r\n\r\n/**\r\n * Heading\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.h4(classes : String? = null, crossinline block : H4.() -> Unit = {}) : HTMLHeadingElement = H4(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block) as HTMLHeadingElement\r\n\r\n/**\r\n * Heading\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.h5(classes : String? = null, crossinline block : H5.() -> Unit = {}) : HTMLHeadingElement = H5(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block) as HTMLHeadingElement\r\n\r\n/**\r\n * Heading\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.h6(classes : String? = null, crossinline block : H6.() -> Unit = {}) : HTMLHeadingElement = H6(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block) as HTMLHeadingElement\r\n\r\n@Deprecated(\"This tag doesn't support content or requires unsafe (try unsafe {})\")\r\n@Suppress(\"DEPRECATION\")\r\n/**\r\n * Document head\r\n */\r\n@HtmlTagMarker\r\npublic fun TagConsumer<HTMLElement>.head(content : String = \"\") : HTMLHeadElement = HEAD(emptyMap, this).visitAndFinalize(this, {+content}) as HTMLHeadElement\r\n/**\r\n * Document head\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.head(crossinline block : HEAD.() -> Unit = {}) : HTMLHeadElement = HEAD(emptyMap, this).visitAndFinalize(this, block) as HTMLHeadElement\r\n\r\n/**\r\n * Introductory or navigational aids for a page or section\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.header(classes : String? = null, crossinline block : HEADER.() -> Unit = {}) : HTMLElement = HEADER(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\r\n\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.hGroup(classes : String? = null, crossinline block : HGROUP.() -> Unit = {}) : HTMLElement = HGROUP(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\r\n\r\n/**\r\n * Horizontal rule\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.hr(classes : String? = null, crossinline block : HR.() -> Unit = {}) : HTMLHRElement = HR(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block) as HTMLHRElement\r\n\r\n@Deprecated(\"This tag doesn't support content or requires unsafe (try unsafe {})\")\r\n@Suppress(\"DEPRECATION\")\r\n/**\r\n * Document root element\r\n */\r\n@HtmlTagMarker\r\npublic fun TagConsumer<HTMLElement>.html(content : String = \"\", namespace : String? = null) : HTMLHtmlElement = HTML(emptyMap, this, namespace).visitAndFinalize(this, {+content}) as HTMLHtmlElement\r\n/**\r\n * Document root element\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.html(namespace : String? = null, crossinline block : HTML.() -> Unit = {}) : HTMLHtmlElement = HTML(emptyMap, this, namespace).visitAndFinalize(this, block) as HTMLHtmlElement\r\n\r\n/**\r\n * Italic text style\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.i(classes : String? = null, crossinline block : I.() -> Unit = {}) : HTMLElement = I(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\r\n\r\n/**\r\n * Inline subwindow\r\n */\r\n@HtmlTagMarker\r\npublic fun TagConsumer<HTMLElement>.iframe(sandbox : IframeSandbox? = null, classes : String? = null, content : String = \"\") : HTMLElement = IFRAME(attributesMapOf(\"sandbox\", sandbox?.enumEncode(),\"class\", classes), this).visitAndFinalize(this, {+content})\r\n/**\r\n * Inline subwindow\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.iframe(sandbox : IframeSandbox? = null, classes : String? = null, crossinline block : IFRAME.() -> Unit = {}) : HTMLElement = IFRAME(attributesMapOf(\"sandbox\", sandbox?.enumEncode(),\"class\", classes), this).visitAndFinalize(this, block)\r\n\r\n/**\r\n * Embedded image\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.img(alt : String? = null, src : String? = null, classes : String? = null, crossinline block : IMG.() -> Unit = {}) : HTMLImageElement = IMG(attributesMapOf(\"alt\", alt,\"src\", src,\"class\", classes), this).visitAndFinalize(this, block) as HTMLImageElement\r\n\r\n/**\r\n * Form control\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.input(type : InputType? = null, formEncType : InputFormEncType? = null, formMethod : InputFormMethod? = null, name : String? = null, classes : String? = null, crossinline block : INPUT.() -> Unit = {}) : HTMLInputElement = INPUT(attributesMapOf(\"type\", type?.enumEncode(),\"formenctype\", formEncType?.enumEncode(),\"formmethod\", formMethod?.enumEncode(),\"name\", name,\"class\", classes), this).visitAndFinalize(this, block) as HTMLInputElement\r\n\r\n/**\r\n * Inserted text\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.ins(classes : String? = null, crossinline block : INS.() -> Unit = {}) : HTMLElement = INS(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\r\n\r\n/**\r\n * Text to be entered by the user\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.kbd(classes : String? = null, crossinline block : KBD.() -> Unit = {}) : HTMLElement = KBD(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\r\n\r\n/**\r\n * Cryptographic key-pair generator form control\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.keyGen(keyType : KeyGenKeyType? = null, classes : String? = null, crossinline block : KEYGEN.() -> Unit = {}) : HTMLElement = KEYGEN(attributesMapOf(\"keytype\", keyType?.enumEncode(),\"class\", classes), this).visitAndFinalize(this, block)\r\n\r\n/**\r\n * Form field label text\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.label(classes : String? = null, crossinline block : LABEL.() -> Unit = {}) : HTMLLabelElement = LABEL(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block) as HTMLLabelElement\r\n\r\n/**\r\n * Fieldset legend\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.legend(classes : String? = null, crossinline block : LEGEND.() -> Unit = {}) : HTMLLegendElement = LEGEND(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block) as HTMLLegendElement\r\n\r\n/**\r\n * List item\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.li(classes : String? = null, crossinline block : LI.() -> Unit = {}) : HTMLLIElement = LI(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block) as HTMLLIElement\r\n\r\n/**\r\n * A media-independent link\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.link(href : String? = null, rel : String? = null, type : String? = null, crossinline block : LINK.() -> Unit = {}) : HTMLLinkElement = LINK(attributesMapOf(\"href\", href,\"rel\", rel,\"type\", type), this).visitAndFinalize(this, block) as HTMLLinkElement\r\n\r\n/**\r\n * Container for the dominant contents of another element\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.main(classes : String? = null, crossinline block : MAIN.() -> Unit = {}) : HTMLElement = MAIN(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\r\n\r\n/**\r\n * Client-side image map\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.map(name : String? = null, classes : String? = null, crossinline block : MAP.() -> Unit = {}) : HTMLMapElement = MAP(attributesMapOf(\"name\", name,\"class\", classes), this).visitAndFinalize(this, block) as HTMLMapElement\r\n\r\n/**\r\n * Highlight\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.mark(classes : String? = null, crossinline block : MARK.() -> Unit = {}) : HTMLElement = MARK(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\r\n\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.math(classes : String? = null, crossinline block : MATH.() -> Unit = {}) : HTMLElement = MATH(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\r\n\r\n@HtmlTagMarker\r\npublic fun TagConsumer<HTMLElement>.mathml(classes : String? = null, content : String = \"\") : HTMLElement = MATHML(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, {+content})\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.mathml(classes : String? = null, crossinline block : MATHML.() -> Unit = {}) : HTMLElement = MATHML(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\r\n\r\n/**\r\n * Generic metainformation\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.meta(name : String? = null, content : String? = null, charset : String? = null, crossinline block : META.() -> Unit = {}) : HTMLMetaElement = META(attributesMapOf(\"name\", name,\"content\", content,\"charset\", charset), this).visitAndFinalize(this, block) as HTMLMetaElement\r\n\r\n/**\r\n * Gauge\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.meter(classes : String? = null, crossinline block : METER.() -> Unit = {}) : HTMLMeterElement = METER(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block) as HTMLMeterElement\r\n\r\n/**\r\n * Section with navigational links\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.nav(classes : String? = null, crossinline block : NAV.() -> Unit = {}) : HTMLElement = NAV(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\r\n\r\n/**\r\n * Generic metainformation\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.noScript(classes : String? = null, crossinline block : NOSCRIPT.() -> Unit = {}) : HTMLElement = NOSCRIPT(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\r\n\r\n/**\r\n * Generic embedded object\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.htmlObject(classes : String? = null, crossinline block : OBJECT.() -> Unit = {}) : HTMLElement = OBJECT(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\r\n\r\n/**\r\n * Ordered list\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.ol(classes : String? = null, crossinline block : OL.() -> Unit = {}) : HTMLElement = OL(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\r\n\r\n/**\r\n * Option group\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.optGroup(label : String? = null, classes : String? = null, crossinline block : OPTGROUP.() -> Unit = {}) : HTMLOptGroupElement = OPTGROUP(attributesMapOf(\"label\", label,\"class\", classes), this).visitAndFinalize(this, block) as HTMLOptGroupElement\r\n\r\n/**\r\n * Selectable choice\r\n */\r\n@HtmlTagMarker\r\npublic fun TagConsumer<HTMLElement>.option(classes : String? = null, content : String = \"\") : HTMLOptionElement = OPTION(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, {+content}) as HTMLOptionElement\r\n/**\r\n * Selectable choice\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.option(classes : String? = null, crossinline block : OPTION.() -> Unit = {}) : HTMLOptionElement = OPTION(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block) as HTMLOptionElement\r\n\r\n/**\r\n * Calculated output value\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.output(classes : String? = null, crossinline block : OUTPUT.() -> Unit = {}) : HTMLOutputElement = OUTPUT(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block) as HTMLOutputElement\r\n\r\n/**\r\n * Paragraph\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.p(classes : String? = null, crossinline block : P.() -> Unit = {}) : HTMLParagraphElement = P(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block) as HTMLParagraphElement\r\n\r\n/**\r\n * Named property value\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.param(name : String? = null, value : String? = null, crossinline block : PARAM.() -> Unit = {}) : HTMLParamElement = PARAM(attributesMapOf(\"name\", name,\"value\", value), this).visitAndFinalize(this, block) as HTMLParamElement\r\n\r\n/**\r\n * Preformatted text\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.pre(classes : String? = null, crossinline block : PRE.() -> Unit = {}) : HTMLPreElement = PRE(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block) as HTMLPreElement\r\n\r\n/**\r\n * Progress bar\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.progress(classes : String? = null, crossinline block : PROGRESS.() -> Unit = {}) : HTMLProgressElement = PROGRESS(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block) as HTMLProgressElement\r\n\r\n/**\r\n * Short inline quotation\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.q(classes : String? = null, crossinline block : Q.() -> Unit = {}) : HTMLElement = Q(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\r\n\r\n/**\r\n * Parenthesis for ruby annotation text\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.rp(classes : String? = null, crossinline block : RP.() -> Unit = {}) : HTMLElement = RP(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\r\n\r\n/**\r\n * Ruby annotation text\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.rt(classes : String? = null, crossinline block : RT.() -> Unit = {}) : HTMLElement = RT(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\r\n\r\n/**\r\n * Ruby annotation(s)\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.ruby(classes : String? = null, crossinline block : RUBY.() -> Unit = {}) : HTMLElement = RUBY(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\r\n\r\n/**\r\n * Strike-through text style\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.samp(classes : String? = null, crossinline block : SAMP.() -> Unit = {}) : HTMLElement = SAMP(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\r\n\r\n@Deprecated(\"This tag doesn't support content or requires unsafe (try unsafe {})\")\r\n@Suppress(\"DEPRECATION\")\r\n/**\r\n * Script statements\r\n */\r\n@HtmlTagMarker\r\npublic fun TagConsumer<HTMLElement>.script(type : String? = null, src : String? = null, content : String = \"\") : HTMLScriptElement = SCRIPT(attributesMapOf(\"type\", type,\"src\", src), this).visitAndFinalize(this, {+content}) as HTMLScriptElement\r\n/**\r\n * Script statements\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.script(type : String? = null, src : String? = null, crossinline block : SCRIPT.() -> Unit = {}) : HTMLScriptElement = SCRIPT(attributesMapOf(\"type\", type,\"src\", src), this).visitAndFinalize(this, block) as HTMLScriptElement\r\n\r\n/**\r\n * Generic document or application section\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.section(classes : String? = null, crossinline block : SECTION.() -> Unit = {}) : HTMLElement = SECTION(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\r\n\r\n/**\r\n * Option selector\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.select(classes : String? = null, crossinline block : SELECT.() -> Unit = {}) : HTMLSelectElement = SELECT(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block) as HTMLSelectElement\r\n\r\n/**\r\n * Small text style\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.small(classes : String? = null, crossinline block : SMALL.() -> Unit = {}) : HTMLElement = SMALL(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\r\n\r\n/**\r\n * Media source for \r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.source(classes : String? = null, crossinline block : SOURCE.() -> Unit = {}) : HTMLSourceElement = SOURCE(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block) as HTMLSourceElement\r\n\r\n/**\r\n * Generic language/style container\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.span(classes : String? = null, crossinline block : SPAN.() -> Unit = {}) : HTMLSpanElement = SPAN(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block) as HTMLSpanElement\r\n\r\n/**\r\n * Strong emphasis\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.strong(classes : String? = null, crossinline block : STRONG.() -> Unit = {}) : HTMLElement = STRONG(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\r\n\r\n@Deprecated(\"This tag doesn't support content or requires unsafe (try unsafe {})\")\r\n@Suppress(\"DEPRECATION\")\r\n/**\r\n * Style info\r\n */\r\n@HtmlTagMarker\r\npublic fun TagConsumer<HTMLElement>.style(type : String? = null, content : String = \"\") : HTMLStyleElement = STYLE(attributesMapOf(\"type\", type), this).visitAndFinalize(this, {+content}) as HTMLStyleElement\r\n/**\r\n * Style info\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.style(type : String? = null, crossinline block : STYLE.() -> Unit = {}) : HTMLStyleElement = STYLE(attributesMapOf(\"type\", type), this).visitAndFinalize(this, block) as HTMLStyleElement\r\n\r\n/**\r\n * Subscript\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.sub(classes : String? = null, crossinline block : SUB.() -> Unit = {}) : HTMLElement = SUB(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\r\n\r\n/**\r\n * Superscript\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.sup(classes : String? = null, crossinline block : SUP.() -> Unit = {}) : HTMLElement = SUP(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\r\n\r\n@HtmlTagMarker\r\npublic fun TagConsumer<HTMLElement>.svg(classes : String? = null, content : String = \"\") : HTMLElement = SVG(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, {+content})\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.svg(classes : String? = null, crossinline block : SVG.() -> Unit = {}) : HTMLElement = SVG(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\r\n\r\n/**\r\n * \r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.table(classes : String? = null, crossinline block : TABLE.() -> Unit = {}) : HTMLTableElement = TABLE(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block) as HTMLTableElement\r\n\r\n/**\r\n * Table body\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.tbody(classes : String? = null, crossinline block : TBODY.() -> Unit = {}) : HTMLTableSectionElement = TBODY(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block) as HTMLTableSectionElement\r\n\r\n/**\r\n * Table data cell\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.td(classes : String? = null, crossinline block : TD.() -> Unit = {}) : HTMLTableCellElement = TD(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block) as HTMLTableCellElement\r\n\r\n/**\r\n * Multi-line text field\r\n */\r\n@HtmlTagMarker\r\npublic fun TagConsumer<HTMLElement>.textArea(rows : String? = null, cols : String? = null, wrap : TextAreaWrap? = null, classes : String? = null, content : String = \"\") : HTMLTextAreaElement = TEXTAREA(attributesMapOf(\"rows\", rows,\"cols\", cols,\"wrap\", wrap?.enumEncode(),\"class\", classes), this).visitAndFinalize(this, {+content}) as HTMLTextAreaElement\r\n/**\r\n * Multi-line text field\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.textArea(rows : String? = null, cols : String? = null, wrap : TextAreaWrap? = null, classes : String? = null, crossinline block : TEXTAREA.() -> Unit = {}) : HTMLTextAreaElement = TEXTAREA(attributesMapOf(\"rows\", rows,\"cols\", cols,\"wrap\", wrap?.enumEncode(),\"class\", classes), this).visitAndFinalize(this, block) as HTMLTextAreaElement\r\n\r\n/**\r\n * Table footer\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.tfoot(classes : String? = null, crossinline block : TFOOT.() -> Unit = {}) : HTMLTableSectionElement = TFOOT(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block) as HTMLTableSectionElement\r\n\r\n/**\r\n * Table header cell\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.th(scope : ThScope? = null, classes : String? = null, crossinline block : TH.() -> Unit = {}) : HTMLTableCellElement = TH(attributesMapOf(\"scope\", scope?.enumEncode(),\"class\", classes), this).visitAndFinalize(this, block) as HTMLTableCellElement\r\n\r\n/**\r\n * Table header\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.thead(classes : String? = null, crossinline block : THEAD.() -> Unit = {}) : HTMLTableSectionElement = THEAD(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block) as HTMLTableSectionElement\r\n\r\n/**\r\n * Machine-readable equivalent of date- or time-related data\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.time(classes : String? = null, crossinline block : TIME.() -> Unit = {}) : HTMLTimeElement = TIME(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block) as HTMLTimeElement\r\n\r\n/**\r\n * Document title\r\n */\r\n@HtmlTagMarker\r\npublic fun TagConsumer<HTMLElement>.title(content : String = \"\") : HTMLTitleElement = TITLE(emptyMap, this).visitAndFinalize(this, {+content}) as HTMLTitleElement\r\n/**\r\n * Document title\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.title(crossinline block : TITLE.() -> Unit = {}) : HTMLTitleElement = TITLE(emptyMap, this).visitAndFinalize(this, block) as HTMLTitleElement\r\n\r\n/**\r\n * Table row\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.tr(classes : String? = null, crossinline block : TR.() -> Unit = {}) : HTMLTableRowElement = TR(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block) as HTMLTableRowElement\r\n\r\n/**\r\n * Unordered list\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.ul(classes : String? = null, crossinline block : UL.() -> Unit = {}) : HTMLElement = UL(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\r\n\r\n/**\r\n * Unordered list\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.htmlVar(classes : String? = null, crossinline block : VAR.() -> Unit = {}) : HTMLElement = VAR(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block)\r\n\r\n/**\r\n * Video player\r\n */\r\n@HtmlTagMarker\r\npublic inline fun TagConsumer<HTMLElement>.video(classes : String? = null, crossinline block : VIDEO.() -> Unit = {}) : HTMLVideoElement = VIDEO(attributesMapOf(\"class\", classes), this).visitAndFinalize(this, block) as HTMLVideoElement\r\n\r\n","package kotlinx.html\r\n\r\nimport org.w3c.dom.events.*\r\n\r\ninterface TagConsumer<out R> {\r\n    fun onTagStart(tag: Tag)\r\n    fun onTagAttributeChange(tag: Tag, attribute: String, value: String?)\r\n    fun onTagEvent(tag: Tag, event: String, value: (Event) -> Unit)\r\n    fun onTagEnd(tag: Tag)\r\n    fun onTagContent(content: CharSequence)\r\n    fun onTagContentEntity(entity: Entities)\r\n    fun onTagContentUnsafe(block: Unsafe.() -> Unit)\r\n    fun onTagComment(content: CharSequence)\r\n    fun onTagError(tag: Tag, exception: Throwable): Unit = throw exception\r\n    fun finalize(): R\r\n}\r\n\r\n@HtmlTagMarker\r\ninterface Tag {\r\n    val tagName: String\r\n    val consumer: TagConsumer<*>\r\n    val namespace: String?\r\n\r\n    val attributes: MutableMap<String, String>\r\n    val attributesEntries: Collection<Map.Entry<String, String>>\r\n\r\n    val inlineTag: Boolean\r\n    val emptyTag: Boolean\r\n\r\n    operator fun Entities.unaryPlus(): Unit {\r\n        entity(this)\r\n    }\r\n\r\n    operator fun String.unaryPlus(): Unit {\r\n        text(this)\r\n    }\r\n\r\n    fun text(s: String) {\r\n        consumer.onTagContent(s)\r\n    }\r\n\r\n    fun text(n: Number) {\r\n        text(n.toString())\r\n    }\r\n\r\n    fun entity(e: Entities) {\r\n        consumer.onTagContentEntity(e)\r\n    }\r\n\r\n    fun comment(s: String) {\r\n        consumer.onTagComment(s)\r\n    }\r\n}\r\n\r\n@HtmlTagMarker\r\ninterface Unsafe {\r\n    operator fun String.unaryPlus()\r\n    operator fun Entities.unaryPlus() = +text\r\n\r\n    fun raw(s: String) {\r\n        +s\r\n    }\r\n\r\n    fun raw(entity: Entities) {\r\n        +entity\r\n    }\r\n\r\n    fun raw(n: Number) {\r\n        +n.toString()\r\n    }\r\n}\r\n\r\ninterface AttributeEnum {\r\n    val realValue: String\r\n}\r\n\r\ninline fun <T : Tag> T.visit(crossinline block: T.() -> Unit) = visitTag { block() }\r\n\r\ninline fun <T : Tag, R> T.visitAndFinalize(consumer: TagConsumer<R>, crossinline block: T.() -> Unit): R\r\n        = visitTagAndFinalize(consumer) { block() }\r\n\r\nfun attributesMapOf() = emptyMap\r\nfun attributesMapOf(key: String, value: String?): Map<String, String> = when (value) {\r\n    null -> emptyMap\r\n    else -> singletonMapOf(key, value)\r\n}\r\n\r\nfun attributesMapOf(vararg pairs: String?): Map<String, String> {\r\n    var result: MutableMap<String, String>? = null\r\n\r\n    for (i in 0..pairs.size - 1 step 2) {\r\n        val k = pairs[i]\r\n        val v = pairs[i + 1]\r\n        if (k != null && v != null) {\r\n            if (result == null) {\r\n                result = linkedMapOf()\r\n            }\r\n            result.put(k, v)\r\n        }\r\n    }\r\n\r\n    return result ?: emptyMap\r\n}\r\n\r\nfun singletonMapOf(key: String, value: String): Map<String, String> = SingletonStringMap(key, value)\r\n\r\nfun HTMLTag.unsafe(block: Unsafe.() -> Unit): Unit = consumer.onTagContentUnsafe(block)\r\n\r\nval emptyMap: Map<String, String> = emptyMap()\r\n\r\nclass DefaultUnsafe : Unsafe {\r\n    private val sb = StringBuilder()\r\n\r\n    override fun String.unaryPlus() {\r\n        sb.append(this)\r\n    }\r\n\r\n    override fun toString(): String = sb.toString()\r\n}\r\n\r\n@DslMarker\r\nannotation class HtmlTagMarker\r\n\r\ntypealias HtmlContent = FlowOrPhrasingContent\r\n\r\nprivate data class SingletonStringMap(override val key: String, override val value: String) : Map<String, String>, Map.Entry<String, String> {\r\n    override val entries: Set<Map.Entry<String, String>>\r\n        get() = setOf(this)\r\n\r\n    override val keys: Set<String>\r\n        get() = setOf(key)\r\n\r\n    override val size: Int\r\n        get() = 1\r\n\r\n    override val values: Collection<String>\r\n        get() = listOf(value)\r\n\r\n    override fun containsKey(key: String) = key == this.key\r\n    override fun containsValue(value: String) = value == this.value\r\n    override fun get(key: String): String? = if (key == this.key) value else null\r\n    override fun isEmpty() = false\r\n}\r\n","package kotlinx.html\r\n\r\nimport kotlinx.html.*\r\nimport kotlinx.html.impl.*\r\nimport kotlinx.html.attributes.*\r\n\r\n/*******************************************************************************\r\n    DO NOT EDIT\r\n    This file was generated by module generate\r\n*******************************************************************************/\r\n\r\ninterface FlowOrHeadingContent : Tag {\r\n}\r\n\r\ninterface FlowOrMetaDataContent : FlowOrPhrasingOrMetaDataContent, Tag {\r\n}\r\n\r\ninterface FlowOrInteractiveContent : FlowOrInteractiveOrPhrasingContent, Tag {\r\n}\r\n\r\ninterface FlowOrPhrasingContent : FlowOrInteractiveOrPhrasingContent, FlowOrPhrasingOrMetaDataContent, Tag {\r\n}\r\n\r\ninterface FlowOrPhrasingOrMetaDataContent : Tag {\r\n}\r\n\r\ninterface SectioningOrFlowContent : Tag {\r\n}\r\n\r\ninterface FlowOrInteractiveOrPhrasingContent : Tag {\r\n}\r\n\r\n\r\n\r\n/**\r\n * Heading\r\n */\r\n@HtmlTagMarker\r\ninline fun FlowOrHeadingContent.h1(classes : String? = null, crossinline block : H1.() -> Unit = {}) : Unit = H1(attributesMapOf(\"class\", classes), consumer).visit(block)\r\n\r\n/**\r\n * Heading\r\n */\r\n@HtmlTagMarker\r\ninline fun FlowOrHeadingContent.h2(classes : String? = null, crossinline block : H2.() -> Unit = {}) : Unit = H2(attributesMapOf(\"class\", classes), consumer).visit(block)\r\n\r\n/**\r\n * Heading\r\n */\r\n@HtmlTagMarker\r\ninline fun FlowOrHeadingContent.h3(classes : String? = null, crossinline block : H3.() -> Unit = {}) : Unit = H3(attributesMapOf(\"class\", classes), consumer).visit(block)\r\n\r\n/**\r\n * Heading\r\n */\r\n@HtmlTagMarker\r\ninline fun FlowOrHeadingContent.h4(classes : String? = null, crossinline block : H4.() -> Unit = {}) : Unit = H4(attributesMapOf(\"class\", classes), consumer).visit(block)\r\n\r\n/**\r\n * Heading\r\n */\r\n@HtmlTagMarker\r\ninline fun FlowOrHeadingContent.h5(classes : String? = null, crossinline block : H5.() -> Unit = {}) : Unit = H5(attributesMapOf(\"class\", classes), consumer).visit(block)\r\n\r\n/**\r\n * Heading\r\n */\r\n@HtmlTagMarker\r\ninline fun FlowOrHeadingContent.h6(classes : String? = null, crossinline block : H6.() -> Unit = {}) : Unit = H6(attributesMapOf(\"class\", classes), consumer).visit(block)\r\n\r\n@HtmlTagMarker\r\ninline fun FlowOrHeadingContent.hGroup(classes : String? = null, crossinline block : HGROUP.() -> Unit = {}) : Unit = HGROUP(attributesMapOf(\"class\", classes), consumer).visit(block)\r\n\r\n\r\n/**\r\n * Style info\r\n */\r\n@HtmlTagMarker\r\ninline fun FlowOrMetaDataContent.style(type : String? = null, crossinline block : STYLE.() -> Unit = {}) : Unit = STYLE(attributesMapOf(\"type\", type), consumer).visit(block)\r\n@Deprecated(\"This tag doesn't support content or requires unsafe (try unsafe {})\")\r\n@Suppress(\"DEPRECATION\")\r\n/**\r\n * Style info\r\n */\r\n@HtmlTagMarker\r\nfun FlowOrMetaDataContent.style(type : String? = null, content : String = \"\") : Unit = STYLE(attributesMapOf(\"type\", type), consumer).visit({+content})\r\n\r\n\r\n/**\r\n * Disclosure control for hiding details\r\n */\r\n@HtmlTagMarker\r\ninline fun FlowOrInteractiveContent.details(classes : String? = null, crossinline block : DETAILS.() -> Unit = {}) : Unit = DETAILS(attributesMapOf(\"class\", classes), consumer).visit(block)\r\n\r\n\r\n/**\r\n * Abbreviated form (e.g., WWW, HTTP,etc.)\r\n */\r\n@HtmlTagMarker\r\ninline fun FlowOrPhrasingContent.abbr(classes : String? = null, crossinline block : ABBR.() -> Unit = {}) : Unit = ABBR(attributesMapOf(\"class\", classes), consumer).visit(block)\r\n\r\n/**\r\n * Client-side image map area\r\n */\r\n@HtmlTagMarker\r\ninline fun FlowOrPhrasingContent.area(shape : AreaShape? = null, alt : String? = null, classes : String? = null, crossinline block : AREA.() -> Unit = {}) : Unit = AREA(attributesMapOf(\"Shape\", shape?.enumEncode(),\"alt\", alt,\"class\", classes), consumer).visit(block)\r\n@HtmlTagMarker\r\ninline fun FlowOrPhrasingContent.rectArea(alt : String? = null, classes : String? = null, crossinline block : AREA.() -> Unit = {}) : Unit = AREA(attributesMapOf(\"Shape\", AreaShape.rect.realValue,\"alt\", alt,\"class\", classes), consumer).visit(block)\r\n@HtmlTagMarker\r\ninline fun FlowOrPhrasingContent.circleArea(alt : String? = null, classes : String? = null, crossinline block : AREA.() -> Unit = {}) : Unit = AREA(attributesMapOf(\"Shape\", AreaShape.circle.realValue,\"alt\", alt,\"class\", classes), consumer).visit(block)\r\n@HtmlTagMarker\r\ninline fun FlowOrPhrasingContent.polyArea(alt : String? = null, classes : String? = null, crossinline block : AREA.() -> Unit = {}) : Unit = AREA(attributesMapOf(\"Shape\", AreaShape.poly.realValue,\"alt\", alt,\"class\", classes), consumer).visit(block)\r\n@HtmlTagMarker\r\ninline fun FlowOrPhrasingContent.defaultArea(alt : String? = null, classes : String? = null, crossinline block : AREA.() -> Unit = {}) : Unit = AREA(attributesMapOf(\"Shape\", AreaShape.default.realValue,\"alt\", alt,\"class\", classes), consumer).visit(block)\r\n\r\n/**\r\n * Bold text style\r\n */\r\n@HtmlTagMarker\r\ninline fun FlowOrPhrasingContent.b(classes : String? = null, crossinline block : B.() -> Unit = {}) : Unit = B(attributesMapOf(\"class\", classes), consumer).visit(block)\r\n\r\n/**\r\n * Text directionality isolation\r\n */\r\n@HtmlTagMarker\r\ninline fun FlowOrPhrasingContent.bdi(classes : String? = null, crossinline block : BDI.() -> Unit = {}) : Unit = BDI(attributesMapOf(\"class\", classes), consumer).visit(block)\r\n\r\n/**\r\n * I18N BiDi over-ride\r\n */\r\n@HtmlTagMarker\r\ninline fun FlowOrPhrasingContent.bdo(classes : String? = null, crossinline block : BDO.() -> Unit = {}) : Unit = BDO(attributesMapOf(\"class\", classes), consumer).visit(block)\r\n\r\n/**\r\n * Forced line break\r\n */\r\n@HtmlTagMarker\r\ninline fun FlowOrPhrasingContent.br(classes : String? = null, crossinline block : BR.() -> Unit = {}) : Unit = BR(attributesMapOf(\"class\", classes), consumer).visit(block)\r\n\r\n/**\r\n * Scriptable bitmap canvas\r\n */\r\n@HtmlTagMarker\r\ninline fun FlowOrPhrasingContent.canvas(classes : String? = null, crossinline block : CANVAS.() -> Unit = {}) : Unit = CANVAS(attributesMapOf(\"class\", classes), consumer).visit(block)\r\n/**\r\n * Scriptable bitmap canvas\r\n */\r\n@HtmlTagMarker\r\nfun FlowOrPhrasingContent.canvas(classes : String? = null, content : String = \"\") : Unit = CANVAS(attributesMapOf(\"class\", classes), consumer).visit({+content})\r\n\r\n/**\r\n * Citation\r\n */\r\n@HtmlTagMarker\r\ninline fun FlowOrPhrasingContent.cite(classes : String? = null, crossinline block : CITE.() -> Unit = {}) : Unit = CITE(attributesMapOf(\"class\", classes), consumer).visit(block)\r\n\r\n/**\r\n * Computer code fragment\r\n */\r\n@HtmlTagMarker\r\ninline fun FlowOrPhrasingContent.code(classes : String? = null, crossinline block : CODE.() -> Unit = {}) : Unit = CODE(attributesMapOf(\"class\", classes), consumer).visit(block)\r\n\r\n/**\r\n * Container for options for \r\n */\r\n@HtmlTagMarker\r\ninline fun FlowOrPhrasingContent.dataList(classes : String? = null, crossinline block : DATALIST.() -> Unit = {}) : Unit = DATALIST(attributesMapOf(\"class\", classes), consumer).visit(block)\r\n\r\n/**\r\n * Deleted text\r\n */\r\n@HtmlTagMarker\r\ninline fun FlowOrPhrasingContent.del(classes : String? = null, crossinline block : DEL.() -> Unit = {}) : Unit = DEL(attributesMapOf(\"class\", classes), consumer).visit(block)\r\n\r\n/**\r\n * Instance definition\r\n */\r\n@HtmlTagMarker\r\ninline fun FlowOrPhrasingContent.dfn(classes : String? = null, crossinline block : DFN.() -> Unit = {}) : Unit = DFN(attributesMapOf(\"class\", classes), consumer).visit(block)\r\n\r\n/**\r\n * Emphasis\r\n */\r\n@HtmlTagMarker\r\ninline fun FlowOrPhrasingContent.em(classes : String? = null, crossinline block : EM.() -> Unit = {}) : Unit = EM(attributesMapOf(\"class\", classes), consumer).visit(block)\r\n\r\n/**\r\n * Italic text style\r\n */\r\n@HtmlTagMarker\r\ninline fun FlowOrPhrasingContent.i(classes : String? = null, crossinline block : I.() -> Unit = {}) : Unit = I(attributesMapOf(\"class\", classes), consumer).visit(block)\r\n\r\n/**\r\n * Inserted text\r\n */\r\n@HtmlTagMarker\r\ninline fun FlowOrPhrasingContent.ins(classes : String? = null, crossinline block : INS.() -> Unit = {}) : Unit = INS(attributesMapOf(\"class\", classes), consumer).visit(block)\r\n\r\n/**\r\n * Text to be entered by the user\r\n */\r\n@HtmlTagMarker\r\ninline fun FlowOrPhrasingContent.kbd(classes : String? = null, crossinline block : KBD.() -> Unit = {}) : Unit = KBD(attributesMapOf(\"class\", classes), consumer).visit(block)\r\n\r\n/**\r\n * Client-side image map\r\n */\r\n@HtmlTagMarker\r\ninline fun FlowOrPhrasingContent.map(name : String? = null, classes : String? = null, crossinline block : MAP.() -> Unit = {}) : Unit = MAP(attributesMapOf(\"name\", name,\"class\", classes), consumer).visit(block)\r\n\r\n/**\r\n * Highlight\r\n */\r\n@HtmlTagMarker\r\ninline fun FlowOrPhrasingContent.mark(classes : String? = null, crossinline block : MARK.() -> Unit = {}) : Unit = MARK(attributesMapOf(\"class\", classes), consumer).visit(block)\r\n\r\n@HtmlTagMarker\r\ninline fun FlowOrPhrasingContent.math(classes : String? = null, crossinline block : MATH.() -> Unit = {}) : Unit = MATH(attributesMapOf(\"class\", classes), consumer).visit(block)\r\n\r\n/**\r\n * Gauge\r\n */\r\n@HtmlTagMarker\r\ninline fun FlowOrPhrasingContent.meter(classes : String? = null, crossinline block : METER.() -> Unit = {}) : Unit = METER(attributesMapOf(\"class\", classes), consumer).visit(block)\r\n\r\n/**\r\n * Calculated output value\r\n */\r\n@HtmlTagMarker\r\ninline fun FlowOrPhrasingContent.output(classes : String? = null, crossinline block : OUTPUT.() -> Unit = {}) : Unit = OUTPUT(attributesMapOf(\"class\", classes), consumer).visit(block)\r\n\r\n/**\r\n * Progress bar\r\n */\r\n@HtmlTagMarker\r\ninline fun FlowOrPhrasingContent.progress(classes : String? = null, crossinline block : PROGRESS.() -> Unit = {}) : Unit = PROGRESS(attributesMapOf(\"class\", classes), consumer).visit(block)\r\n\r\n/**\r\n * Short inline quotation\r\n */\r\n@HtmlTagMarker\r\ninline fun FlowOrPhrasingContent.q(classes : String? = null, crossinline block : Q.() -> Unit = {}) : Unit = Q(attributesMapOf(\"class\", classes), consumer).visit(block)\r\n\r\n/**\r\n * Ruby annotation(s)\r\n */\r\n@HtmlTagMarker\r\ninline fun FlowOrPhrasingContent.ruby(classes : String? = null, crossinline block : RUBY.() -> Unit = {}) : Unit = RUBY(attributesMapOf(\"class\", classes), consumer).visit(block)\r\n\r\n/**\r\n * Strike-through text style\r\n */\r\n@HtmlTagMarker\r\ninline fun FlowOrPhrasingContent.samp(classes : String? = null, crossinline block : SAMP.() -> Unit = {}) : Unit = SAMP(attributesMapOf(\"class\", classes), consumer).visit(block)\r\n\r\n/**\r\n * Small text style\r\n */\r\n@HtmlTagMarker\r\ninline fun FlowOrPhrasingContent.small(classes : String? = null, crossinline block : SMALL.() -> Unit = {}) : Unit = SMALL(attributesMapOf(\"class\", classes), consumer).visit(block)\r\n\r\n/**\r\n * Generic language/style container\r\n */\r\n@HtmlTagMarker\r\ninline fun FlowOrPhrasingContent.span(classes : String? = null, crossinline block : SPAN.() -> Unit = {}) : Unit = SPAN(attributesMapOf(\"class\", classes), consumer).visit(block)\r\n\r\n/**\r\n * Strong emphasis\r\n */\r\n@HtmlTagMarker\r\ninline fun FlowOrPhrasingContent.strong(classes : String? = null, crossinline block : STRONG.() -> Unit = {}) : Unit = STRONG(attributesMapOf(\"class\", classes), consumer).visit(block)\r\n\r\n/**\r\n * Subscript\r\n */\r\n@HtmlTagMarker\r\ninline fun FlowOrPhrasingContent.sub(classes : String? = null, crossinline block : SUB.() -> Unit = {}) : Unit = SUB(attributesMapOf(\"class\", classes), consumer).visit(block)\r\n\r\n/**\r\n * Superscript\r\n */\r\n@HtmlTagMarker\r\ninline fun FlowOrPhrasingContent.sup(classes : String? = null, crossinline block : SUP.() -> Unit = {}) : Unit = SUP(attributesMapOf(\"class\", classes), consumer).visit(block)\r\n\r\n@HtmlTagMarker\r\ninline fun FlowOrPhrasingContent.svg(classes : String? = null, crossinline block : SVG.() -> Unit = {}) : Unit = SVG(attributesMapOf(\"class\", classes), consumer).visit(block)\r\n@HtmlTagMarker\r\nfun FlowOrPhrasingContent.svg(classes : String? = null, content : String = \"\") : Unit = SVG(attributesMapOf(\"class\", classes), consumer).visit({+content})\r\n\r\n/**\r\n * Machine-readable equivalent of date- or time-related data\r\n */\r\n@HtmlTagMarker\r\ninline fun FlowOrPhrasingContent.time(classes : String? = null, crossinline block : TIME.() -> Unit = {}) : Unit = TIME(attributesMapOf(\"class\", classes), consumer).visit(block)\r\n\r\n/**\r\n * Unordered list\r\n */\r\n@HtmlTagMarker\r\ninline fun FlowOrPhrasingContent.htmlVar(classes : String? = null, crossinline block : VAR.() -> Unit = {}) : Unit = VAR(attributesMapOf(\"class\", classes), consumer).visit(block)\r\n\r\n\r\n@HtmlTagMarker\r\ninline fun FlowOrPhrasingOrMetaDataContent.command(type : CommandType? = null, classes : String? = null, crossinline block : COMMAND.() -> Unit = {}) : Unit = COMMAND(attributesMapOf(\"type\", type?.enumEncode(),\"class\", classes), consumer).visit(block)\r\n@HtmlTagMarker\r\ninline fun FlowOrPhrasingOrMetaDataContent.commandCommand(classes : String? = null, crossinline block : COMMAND.() -> Unit = {}) : Unit = COMMAND(attributesMapOf(\"type\", CommandType.command.realValue,\"class\", classes), consumer).visit(block)\r\n@HtmlTagMarker\r\ninline fun FlowOrPhrasingOrMetaDataContent.checkBoxCommand(classes : String? = null, crossinline block : COMMAND.() -> Unit = {}) : Unit = COMMAND(attributesMapOf(\"type\", CommandType.checkBox.realValue,\"class\", classes), consumer).visit(block)\r\n@HtmlTagMarker\r\ninline fun FlowOrPhrasingOrMetaDataContent.radioCommand(classes : String? = null, crossinline block : COMMAND.() -> Unit = {}) : Unit = COMMAND(attributesMapOf(\"type\", CommandType.radio.realValue,\"class\", classes), consumer).visit(block)\r\n\r\n/**\r\n * A media-independent link\r\n */\r\n@HtmlTagMarker\r\ninline fun FlowOrPhrasingOrMetaDataContent.link(href : String? = null, rel : String? = null, type : String? = null, crossinline block : LINK.() -> Unit = {}) : Unit = LINK(attributesMapOf(\"href\", href,\"rel\", rel,\"type\", type), consumer).visit(block)\r\n\r\n/**\r\n * Generic metainformation\r\n */\r\n@HtmlTagMarker\r\ninline fun FlowOrPhrasingOrMetaDataContent.meta(name : String? = null, content : String? = null, charset : String? = null, crossinline block : META.() -> Unit = {}) : Unit = META(attributesMapOf(\"name\", name,\"content\", content,\"charset\", charset), consumer).visit(block)\r\n\r\n/**\r\n * Generic metainformation\r\n */\r\n@HtmlTagMarker\r\ninline fun FlowOrPhrasingOrMetaDataContent.noScript(classes : String? = null, crossinline block : NOSCRIPT.() -> Unit = {}) : Unit = NOSCRIPT(attributesMapOf(\"class\", classes), consumer).visit(block)\r\n\r\n/**\r\n * Script statements\r\n */\r\n@HtmlTagMarker\r\ninline fun FlowOrPhrasingOrMetaDataContent.script(type : String? = null, src : String? = null, crossinline block : SCRIPT.() -> Unit = {}) : Unit = SCRIPT(attributesMapOf(\"type\", type,\"src\", src), consumer).visit(block)\r\n@Deprecated(\"This tag doesn't support content or requires unsafe (try unsafe {})\")\r\n@Suppress(\"DEPRECATION\")\r\n/**\r\n * Script statements\r\n */\r\n@HtmlTagMarker\r\nfun FlowOrPhrasingOrMetaDataContent.script(type : String? = null, src : String? = null, content : String = \"\") : Unit = SCRIPT(attributesMapOf(\"type\", type,\"src\", src), consumer).visit({+content})\r\n\r\n\r\n/**\r\n * Self-contained syndicatable or reusable composition\r\n */\r\n@HtmlTagMarker\r\ninline fun SectioningOrFlowContent.article(classes : String? = null, crossinline block : ARTICLE.() -> Unit = {}) : Unit = ARTICLE(attributesMapOf(\"class\", classes), consumer).visit(block)\r\n\r\n/**\r\n * Sidebar for tangentially related content\r\n */\r\n@HtmlTagMarker\r\ninline fun SectioningOrFlowContent.aside(classes : String? = null, crossinline block : ASIDE.() -> Unit = {}) : Unit = ASIDE(attributesMapOf(\"class\", classes), consumer).visit(block)\r\n\r\n/**\r\n * Container for the dominant contents of another element\r\n */\r\n@HtmlTagMarker\r\ninline fun SectioningOrFlowContent.main(classes : String? = null, crossinline block : MAIN.() -> Unit = {}) : Unit = MAIN(attributesMapOf(\"class\", classes), consumer).visit(block)\r\n\r\n/**\r\n * Section with navigational links\r\n */\r\n@HtmlTagMarker\r\ninline fun SectioningOrFlowContent.nav(classes : String? = null, crossinline block : NAV.() -> Unit = {}) : Unit = NAV(attributesMapOf(\"class\", classes), consumer).visit(block)\r\n\r\n/**\r\n * Generic document or application section\r\n */\r\n@HtmlTagMarker\r\ninline fun SectioningOrFlowContent.section(classes : String? = null, crossinline block : SECTION.() -> Unit = {}) : Unit = SECTION(attributesMapOf(\"class\", classes), consumer).visit(block)\r\n\r\n\r\n/**\r\n * Anchor\r\n */\r\n@HtmlTagMarker\r\ninline fun FlowOrInteractiveOrPhrasingContent.a(href : String? = null, target : String? = null, classes : String? = null, crossinline block : A.() -> Unit = {}) : Unit = A(attributesMapOf(\"href\", href,\"target\", target,\"class\", classes), consumer).visit(block)\r\n\r\n/**\r\n * Audio player\r\n */\r\n@HtmlTagMarker\r\ninline fun FlowOrInteractiveOrPhrasingContent.audio(classes : String? = null, crossinline block : AUDIO.() -> Unit = {}) : Unit = AUDIO(attributesMapOf(\"class\", classes), consumer).visit(block)\r\n\r\n/**\r\n * Push button\r\n */\r\n@HtmlTagMarker\r\ninline fun FlowOrInteractiveOrPhrasingContent.button(formEncType : ButtonFormEncType? = null, formMethod : ButtonFormMethod? = null, name : String? = null, type : ButtonType? = null, classes : String? = null, crossinline block : BUTTON.() -> Unit = {}) : Unit = BUTTON(attributesMapOf(\"formenctype\", formEncType?.enumEncode(),\"formmethod\", formMethod?.enumEncode(),\"name\", name,\"type\", type?.enumEncode(),\"class\", classes), consumer).visit(block)\r\n@HtmlTagMarker\r\ninline fun FlowOrInteractiveOrPhrasingContent.getButton(formEncType : ButtonFormEncType? = null, name : String? = null, type : ButtonType? = null, classes : String? = null, crossinline block : BUTTON.() -> Unit = {}) : Unit = BUTTON(attributesMapOf(\"formenctype\", formEncType?.enumEncode(),\"formmethod\", ButtonFormMethod.get.realValue,\"name\", name,\"type\", type?.enumEncode(),\"class\", classes), consumer).visit(block)\r\n@HtmlTagMarker\r\ninline fun FlowOrInteractiveOrPhrasingContent.postButton(formEncType : ButtonFormEncType? = null, name : String? = null, type : ButtonType? = null, classes : String? = null, crossinline block : BUTTON.() -> Unit = {}) : Unit = BUTTON(attributesMapOf(\"formenctype\", formEncType?.enumEncode(),\"formmethod\", ButtonFormMethod.post.realValue,\"name\", name,\"type\", type?.enumEncode(),\"class\", classes), consumer).visit(block)\r\n@Suppress(\"DEPRECATION\")\r\n@HtmlTagMarker\r\ninline fun FlowOrInteractiveOrPhrasingContent.putButton(formEncType : ButtonFormEncType? = null, name : String? = null, type : ButtonType? = null, classes : String? = null, crossinline block : BUTTON.() -> Unit = {}) : Unit = BUTTON(attributesMapOf(\"formenctype\", formEncType?.enumEncode(),\"formmethod\", ButtonFormMethod.put.realValue,\"name\", name,\"type\", type?.enumEncode(),\"class\", classes), consumer).visit(block)\r\n@Suppress(\"DEPRECATION\")\r\n@HtmlTagMarker\r\ninline fun FlowOrInteractiveOrPhrasingContent.deleteButton(formEncType : ButtonFormEncType? = null, name : String? = null, type : ButtonType? = null, classes : String? = null, crossinline block : BUTTON.() -> Unit = {}) : Unit = BUTTON(attributesMapOf(\"formenctype\", formEncType?.enumEncode(),\"formmethod\", ButtonFormMethod.delete.realValue,\"name\", name,\"type\", type?.enumEncode(),\"class\", classes), consumer).visit(block)\r\n@Suppress(\"DEPRECATION\")\r\n@HtmlTagMarker\r\ninline fun FlowOrInteractiveOrPhrasingContent.patchButton(formEncType : ButtonFormEncType? = null, name : String? = null, type : ButtonType? = null, classes : String? = null, crossinline block : BUTTON.() -> Unit = {}) : Unit = BUTTON(attributesMapOf(\"formenctype\", formEncType?.enumEncode(),\"formmethod\", ButtonFormMethod.patch.realValue,\"name\", name,\"type\", type?.enumEncode(),\"class\", classes), consumer).visit(block)\r\n\r\n/**\r\n * Plugin\r\n */\r\n@HtmlTagMarker\r\ninline fun FlowOrInteractiveOrPhrasingContent.embed(classes : String? = null, crossinline block : EMBED.() -> Unit = {}) : Unit = EMBED(attributesMapOf(\"class\", classes), consumer).visit(block)\r\n\r\n/**\r\n * Inline subwindow\r\n */\r\n@HtmlTagMarker\r\ninline fun FlowOrInteractiveOrPhrasingContent.iframe(sandbox : IframeSandbox? = null, classes : String? = null, crossinline block : IFRAME.() -> Unit = {}) : Unit = IFRAME(attributesMapOf(\"sandbox\", sandbox?.enumEncode(),\"class\", classes), consumer).visit(block)\r\n/**\r\n * Inline subwindow\r\n */\r\n@HtmlTagMarker\r\nfun FlowOrInteractiveOrPhrasingContent.iframe(sandbox : IframeSandbox? = null, classes : String? = null, content : String = \"\") : Unit = IFRAME(attributesMapOf(\"sandbox\", sandbox?.enumEncode(),\"class\", classes), consumer).visit({+content})\r\n@HtmlTagMarker\r\ninline fun FlowOrInteractiveOrPhrasingContent.allowSameOriginIframe(classes : String? = null, crossinline block : IFRAME.() -> Unit = {}) : Unit = IFRAME(attributesMapOf(\"sandbox\", IframeSandbox.allowSameOrigin.realValue,\"class\", classes), consumer).visit(block)\r\n@HtmlTagMarker\r\ninline fun FlowOrInteractiveOrPhrasingContent.allowFormSIframe(classes : String? = null, crossinline block : IFRAME.() -> Unit = {}) : Unit = IFRAME(attributesMapOf(\"sandbox\", IframeSandbox.allowFormS.realValue,\"class\", classes), consumer).visit(block)\r\n@HtmlTagMarker\r\ninline fun FlowOrInteractiveOrPhrasingContent.allowScriptsIframe(classes : String? = null, crossinline block : IFRAME.() -> Unit = {}) : Unit = IFRAME(attributesMapOf(\"sandbox\", IframeSandbox.allowScripts.realValue,\"class\", classes), consumer).visit(block)\r\n@HtmlTagMarker\r\nfun FlowOrInteractiveOrPhrasingContent.allowSameOriginIframe(classes : String? = null, content : String = \"\") : Unit = IFRAME(attributesMapOf(\"sandbox\", IframeSandbox.allowSameOrigin.realValue,\"class\", classes), consumer).visit({+content})\r\n@HtmlTagMarker\r\nfun FlowOrInteractiveOrPhrasingContent.allowFormSIframe(classes : String? = null, content : String = \"\") : Unit = IFRAME(attributesMapOf(\"sandbox\", IframeSandbox.allowFormS.realValue,\"class\", classes), consumer).visit({+content})\r\n@HtmlTagMarker\r\nfun FlowOrInteractiveOrPhrasingContent.allowScriptsIframe(classes : String? = null, content : String = \"\") : Unit = IFRAME(attributesMapOf(\"sandbox\", IframeSandbox.allowScripts.realValue,\"class\", classes), consumer).visit({+content})\r\n\r\n/**\r\n * Embedded image\r\n */\r\n@HtmlTagMarker\r\ninline fun FlowOrInteractiveOrPhrasingContent.img(alt : String? = null, src : String? = null, classes : String? = null, crossinline block : IMG.() -> Unit = {}) : Unit = IMG(attributesMapOf(\"alt\", alt,\"src\", src,\"class\", classes), consumer).visit(block)\r\n\r\n/**\r\n * Form control\r\n */\r\n@HtmlTagMarker\r\ninline fun FlowOrInteractiveOrPhrasingContent.input(type : InputType? = null, formEncType : InputFormEncType? = null, formMethod : InputFormMethod? = null, name : String? = null, classes : String? = null, crossinline block : INPUT.() -> Unit = {}) : Unit = INPUT(attributesMapOf(\"type\", type?.enumEncode(),\"formenctype\", formEncType?.enumEncode(),\"formmethod\", formMethod?.enumEncode(),\"name\", name,\"class\", classes), consumer).visit(block)\r\n@HtmlTagMarker\r\ninline fun FlowOrInteractiveOrPhrasingContent.buttonInput(formEncType : InputFormEncType? = null, formMethod : InputFormMethod? = null, name : String? = null, classes : String? = null, crossinline block : INPUT.() -> Unit = {}) : Unit = INPUT(attributesMapOf(\"type\", InputType.button.realValue,\"formenctype\", formEncType?.enumEncode(),\"formmethod\", formMethod?.enumEncode(),\"name\", name,\"class\", classes), consumer).visit(block)\r\n@HtmlTagMarker\r\ninline fun FlowOrInteractiveOrPhrasingContent.checkBoxInput(formEncType : InputFormEncType? = null, formMethod : InputFormMethod? = null, name : String? = null, classes : String? = null, crossinline block : INPUT.() -> Unit = {}) : Unit = INPUT(attributesMapOf(\"type\", InputType.checkBox.realValue,\"formenctype\", formEncType?.enumEncode(),\"formmethod\", formMethod?.enumEncode(),\"name\", name,\"class\", classes), consumer).visit(block)\r\n@HtmlTagMarker\r\ninline fun FlowOrInteractiveOrPhrasingContent.colorInput(formEncType : InputFormEncType? = null, formMethod : InputFormMethod? = null, name : String? = null, classes : String? = null, crossinline block : INPUT.() -> Unit = {}) : Unit = INPUT(attributesMapOf(\"type\", InputType.color.realValue,\"formenctype\", formEncType?.enumEncode(),\"formmethod\", formMethod?.enumEncode(),\"name\", name,\"class\", classes), consumer).visit(block)\r\n@HtmlTagMarker\r\ninline fun FlowOrInteractiveOrPhrasingContent.dateInput(formEncType : InputFormEncType? = null, formMethod : InputFormMethod? = null, name : String? = null, classes : String? = null, crossinline block : INPUT.() -> Unit = {}) : Unit = INPUT(attributesMapOf(\"type\", InputType.date.realValue,\"formenctype\", formEncType?.enumEncode(),\"formmethod\", formMethod?.enumEncode(),\"name\", name,\"class\", classes), consumer).visit(block)\r\n@HtmlTagMarker\r\ninline fun FlowOrInteractiveOrPhrasingContent.dateTimeInput(formEncType : InputFormEncType? = null, formMethod : InputFormMethod? = null, name : String? = null, classes : String? = null, crossinline block : INPUT.() -> Unit = {}) : Unit = INPUT(attributesMapOf(\"type\", InputType.dateTime.realValue,\"formenctype\", formEncType?.enumEncode(),\"formmethod\", formMethod?.enumEncode(),\"name\", name,\"class\", classes), consumer).visit(block)\r\n@HtmlTagMarker\r\ninline fun FlowOrInteractiveOrPhrasingContent.dateTimeLocalInput(formEncType : InputFormEncType? = null, formMethod : InputFormMethod? = null, name : String? = null, classes : String? = null, crossinline block : INPUT.() -> Unit = {}) : Unit = INPUT(attributesMapOf(\"type\", InputType.dateTimeLocal.realValue,\"formenctype\", formEncType?.enumEncode(),\"formmethod\", formMethod?.enumEncode(),\"name\", name,\"class\", classes), consumer).visit(block)\r\n@HtmlTagMarker\r\ninline fun FlowOrInteractiveOrPhrasingContent.emailInput(formEncType : InputFormEncType? = null, formMethod : InputFormMethod? = null, name : String? = null, classes : String? = null, crossinline block : INPUT.() -> Unit = {}) : Unit = INPUT(attributesMapOf(\"type\", InputType.email.realValue,\"formenctype\", formEncType?.enumEncode(),\"formmethod\", formMethod?.enumEncode(),\"name\", name,\"class\", classes), consumer).visit(block)\r\n@HtmlTagMarker\r\ninline fun FlowOrInteractiveOrPhrasingContent.fileInput(formEncType : InputFormEncType? = null, formMethod : InputFormMethod? = null, name : String? = null, classes : String? = null, crossinline block : INPUT.() -> Unit = {}) : Unit = INPUT(attributesMapOf(\"type\", InputType.file.realValue,\"formenctype\", formEncType?.enumEncode(),\"formmethod\", formMethod?.enumEncode(),\"name\", name,\"class\", classes), consumer).visit(block)\r\n@HtmlTagMarker\r\ninline fun FlowOrInteractiveOrPhrasingContent.hiddenInput(formEncType : InputFormEncType? = null, formMethod : InputFormMethod? = null, name : String? = null, classes : String? = null, crossinline block : INPUT.() -> Unit = {}) : Unit = INPUT(attributesMapOf(\"type\", InputType.hidden.realValue,\"formenctype\", formEncType?.enumEncode(),\"formmethod\", formMethod?.enumEncode(),\"name\", name,\"class\", classes), consumer).visit(block)\r\n@HtmlTagMarker\r\ninline fun FlowOrInteractiveOrPhrasingContent.imageInput(formEncType : InputFormEncType? = null, formMethod : InputFormMethod? = null, name : String? = null, classes : String? = null, crossinline block : INPUT.() -> Unit = {}) : Unit = INPUT(attributesMapOf(\"type\", InputType.image.realValue,\"formenctype\", formEncType?.enumEncode(),\"formmethod\", formMethod?.enumEncode(),\"name\", name,\"class\", classes), consumer).visit(block)\r\n@HtmlTagMarker\r\ninline fun FlowOrInteractiveOrPhrasingContent.monthInput(formEncType : InputFormEncType? = null, formMethod : InputFormMethod? = null, name : String? = null, classes : String? = null, crossinline block : INPUT.() -> Unit = {}) : Unit = INPUT(attributesMapOf(\"type\", InputType.month.realValue,\"formenctype\", formEncType?.enumEncode(),\"formmethod\", formMethod?.enumEncode(),\"name\", name,\"class\", classes), consumer).visit(block)\r\n@HtmlTagMarker\r\ninline fun FlowOrInteractiveOrPhrasingContent.numberInput(formEncType : InputFormEncType? = null, formMethod : InputFormMethod? = null, name : String? = null, classes : String? = null, crossinline block : INPUT.() -> Unit = {}) : Unit = INPUT(attributesMapOf(\"type\", InputType.number.realValue,\"formenctype\", formEncType?.enumEncode(),\"formmethod\", formMethod?.enumEncode(),\"name\", name,\"class\", classes), consumer).visit(block)\r\n@HtmlTagMarker\r\ninline fun FlowOrInteractiveOrPhrasingContent.passwordInput(formEncType : InputFormEncType? = null, formMethod : InputFormMethod? = null, name : String? = null, classes : String? = null, crossinline block : INPUT.() -> Unit = {}) : Unit = INPUT(attributesMapOf(\"type\", InputType.password.realValue,\"formenctype\", formEncType?.enumEncode(),\"formmethod\", formMethod?.enumEncode(),\"name\", name,\"class\", classes), consumer).visit(block)\r\n@HtmlTagMarker\r\ninline fun FlowOrInteractiveOrPhrasingContent.radioInput(formEncType : InputFormEncType? = null, formMethod : InputFormMethod? = null, name : String? = null, classes : String? = null, crossinline block : INPUT.() -> Unit = {}) : Unit = INPUT(attributesMapOf(\"type\", InputType.radio.realValue,\"formenctype\", formEncType?.enumEncode(),\"formmethod\", formMethod?.enumEncode(),\"name\", name,\"class\", classes), consumer).visit(block)\r\n@HtmlTagMarker\r\ninline fun FlowOrInteractiveOrPhrasingContent.rangeInput(formEncType : InputFormEncType? = null, formMethod : InputFormMethod? = null, name : String? = null, classes : String? = null, crossinline block : INPUT.() -> Unit = {}) : Unit = INPUT(attributesMapOf(\"type\", InputType.range.realValue,\"formenctype\", formEncType?.enumEncode(),\"formmethod\", formMethod?.enumEncode(),\"name\", name,\"class\", classes), consumer).visit(block)\r\n@HtmlTagMarker\r\ninline fun FlowOrInteractiveOrPhrasingContent.resetInput(formEncType : InputFormEncType? = null, formMethod : InputFormMethod? = null, name : String? = null, classes : String? = null, crossinline block : INPUT.() -> Unit = {}) : Unit = INPUT(attributesMapOf(\"type\", InputType.reset.realValue,\"formenctype\", formEncType?.enumEncode(),\"formmethod\", formMethod?.enumEncode(),\"name\", name,\"class\", classes), consumer).visit(block)\r\n@HtmlTagMarker\r\ninline fun FlowOrInteractiveOrPhrasingContent.searchInput(formEncType : InputFormEncType? = null, formMethod : InputFormMethod? = null, name : String? = null, classes : String? = null, crossinline block : INPUT.() -> Unit = {}) : Unit = INPUT(attributesMapOf(\"type\", InputType.search.realValue,\"formenctype\", formEncType?.enumEncode(),\"formmethod\", formMethod?.enumEncode(),\"name\", name,\"class\", classes), consumer).visit(block)\r\n@HtmlTagMarker\r\ninline fun FlowOrInteractiveOrPhrasingContent.submitInput(formEncType : InputFormEncType? = null, formMethod : InputFormMethod? = null, name : String? = null, classes : String? = null, crossinline block : INPUT.() -> Unit = {}) : Unit = INPUT(attributesMapOf(\"type\", InputType.submit.realValue,\"formenctype\", formEncType?.enumEncode(),\"formmethod\", formMethod?.enumEncode(),\"name\", name,\"class\", classes), consumer).visit(block)\r\n@HtmlTagMarker\r\ninline fun FlowOrInteractiveOrPhrasingContent.textInput(formEncType : InputFormEncType? = null, formMethod : InputFormMethod? = null, name : String? = null, classes : String? = null, crossinline block : INPUT.() -> Unit = {}) : Unit = INPUT(attributesMapOf(\"type\", InputType.text.realValue,\"formenctype\", formEncType?.enumEncode(),\"formmethod\", formMethod?.enumEncode(),\"name\", name,\"class\", classes), consumer).visit(block)\r\n@HtmlTagMarker\r\ninline fun FlowOrInteractiveOrPhrasingContent.telInput(formEncType : InputFormEncType? = null, formMethod : InputFormMethod? = null, name : String? = null, classes : String? = null, crossinline block : INPUT.() -> Unit = {}) : Unit = INPUT(attributesMapOf(\"type\", InputType.tel.realValue,\"formenctype\", formEncType?.enumEncode(),\"formmethod\", formMethod?.enumEncode(),\"name\", name,\"class\", classes), consumer).visit(block)\r\n@HtmlTagMarker\r\ninline fun FlowOrInteractiveOrPhrasingContent.timeInput(formEncType : InputFormEncType? = null, formMethod : InputFormMethod? = null, name : String? = null, classes : String? = null, crossinline block : INPUT.() -> Unit = {}) : Unit = INPUT(attributesMapOf(\"type\", InputType.time.realValue,\"formenctype\", formEncType?.enumEncode(),\"formmethod\", formMethod?.enumEncode(),\"name\", name,\"class\", classes), consumer).visit(block)\r\n@HtmlTagMarker\r\ninline fun FlowOrInteractiveOrPhrasingContent.urlInput(formEncType : InputFormEncType? = null, formMethod : InputFormMethod? = null, name : String? = null, classes : String? = null, crossinline block : INPUT.() -> Unit = {}) : Unit = INPUT(attributesMapOf(\"type\", InputType.url.realValue,\"formenctype\", formEncType?.enumEncode(),\"formmethod\", formMethod?.enumEncode(),\"name\", name,\"class\", classes), consumer).visit(block)\r\n@HtmlTagMarker\r\ninline fun FlowOrInteractiveOrPhrasingContent.weekInput(formEncType : InputFormEncType? = null, formMethod : InputFormMethod? = null, name : String? = null, classes : String? = null, crossinline block : INPUT.() -> Unit = {}) : Unit = INPUT(attributesMapOf(\"type\", InputType.week.realValue,\"formenctype\", formEncType?.enumEncode(),\"formmethod\", formMethod?.enumEncode(),\"name\", name,\"class\", classes), consumer).visit(block)\r\n\r\n/**\r\n * Cryptographic key-pair generator form control\r\n */\r\n@HtmlTagMarker\r\ninline fun FlowOrInteractiveOrPhrasingContent.keyGen(keyType : KeyGenKeyType? = null, classes : String? = null, crossinline block : KEYGEN.() -> Unit = {}) : Unit = KEYGEN(attributesMapOf(\"keytype\", keyType?.enumEncode(),\"class\", classes), consumer).visit(block)\r\n@HtmlTagMarker\r\ninline fun FlowOrInteractiveOrPhrasingContent.rsaKeyGen(classes : String? = null, crossinline block : KEYGEN.() -> Unit = {}) : Unit = KEYGEN(attributesMapOf(\"keytype\", KeyGenKeyType.rsa.realValue,\"class\", classes), consumer).visit(block)\r\n\r\n/**\r\n * Form field label text\r\n */\r\n@HtmlTagMarker\r\ninline fun FlowOrInteractiveOrPhrasingContent.label(classes : String? = null, crossinline block : LABEL.() -> Unit = {}) : Unit = LABEL(attributesMapOf(\"class\", classes), consumer).visit(block)\r\n\r\n/**\r\n * Generic embedded object\r\n */\r\n@HtmlTagMarker\r\ninline fun FlowOrInteractiveOrPhrasingContent.htmlObject(classes : String? = null, crossinline block : OBJECT.() -> Unit = {}) : Unit = OBJECT(attributesMapOf(\"class\", classes), consumer).visit(block)\r\n\r\n/**\r\n * Option selector\r\n */\r\n@HtmlTagMarker\r\ninline fun FlowOrInteractiveOrPhrasingContent.select(classes : String? = null, crossinline block : SELECT.() -> Unit = {}) : Unit = SELECT(attributesMapOf(\"class\", classes), consumer).visit(block)\r\n\r\n/**\r\n * Multi-line text field\r\n */\r\n@HtmlTagMarker\r\ninline fun FlowOrInteractiveOrPhrasingContent.textArea(rows : String? = null, cols : String? = null, wrap : TextAreaWrap? = null, classes : String? = null, crossinline block : TEXTAREA.() -> Unit = {}) : Unit = TEXTAREA(attributesMapOf(\"rows\", rows,\"cols\", cols,\"wrap\", wrap?.enumEncode(),\"class\", classes), consumer).visit(block)\r\n/**\r\n * Multi-line text field\r\n */\r\n@HtmlTagMarker\r\nfun FlowOrInteractiveOrPhrasingContent.textArea(rows : String? = null, cols : String? = null, wrap : TextAreaWrap? = null, classes : String? = null, content : String = \"\") : Unit = TEXTAREA(attributesMapOf(\"rows\", rows,\"cols\", cols,\"wrap\", wrap?.enumEncode(),\"class\", classes), consumer).visit({+content})\r\n@HtmlTagMarker\r\ninline fun FlowOrInteractiveOrPhrasingContent.hardTextArea(rows : String? = null, cols : String? = null, classes : String? = null, crossinline block : TEXTAREA.() -> Unit = {}) : Unit = TEXTAREA(attributesMapOf(\"rows\", rows,\"cols\", cols,\"wrap\", TextAreaWrap.hard.realValue,\"class\", classes), consumer).visit(block)\r\n@HtmlTagMarker\r\ninline fun FlowOrInteractiveOrPhrasingContent.softTextArea(rows : String? = null, cols : String? = null, classes : String? = null, crossinline block : TEXTAREA.() -> Unit = {}) : Unit = TEXTAREA(attributesMapOf(\"rows\", rows,\"cols\", cols,\"wrap\", TextAreaWrap.soft.realValue,\"class\", classes), consumer).visit(block)\r\n@HtmlTagMarker\r\nfun FlowOrInteractiveOrPhrasingContent.hardTextArea(rows : String? = null, cols : String? = null, classes : String? = null, content : String = \"\") : Unit = TEXTAREA(attributesMapOf(\"rows\", rows,\"cols\", cols,\"wrap\", TextAreaWrap.hard.realValue,\"class\", classes), consumer).visit({+content})\r\n@HtmlTagMarker\r\nfun FlowOrInteractiveOrPhrasingContent.softTextArea(rows : String? = null, cols : String? = null, classes : String? = null, content : String = \"\") : Unit = TEXTAREA(attributesMapOf(\"rows\", rows,\"cols\", cols,\"wrap\", TextAreaWrap.soft.realValue,\"class\", classes), consumer).visit({+content})\r\n\r\n/**\r\n * Video player\r\n */\r\n@HtmlTagMarker\r\ninline fun FlowOrInteractiveOrPhrasingContent.video(classes : String? = null, crossinline block : VIDEO.() -> Unit = {}) : Unit = VIDEO(attributesMapOf(\"class\", classes), consumer).visit(block)\r\n\r\n\r\n","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\nimport kotlin.ranges.contains\nimport kotlin.ranges.reversed\n\n/**\n * Returns 1st *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component1(): T {\n    return get(0)\n}\n\n/**\n * Returns 2nd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component2(): T {\n    return get(1)\n}\n\n/**\n * Returns 3rd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component3(): T {\n    return get(2)\n}\n\n/**\n * Returns 4th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component4(): T {\n    return get(3)\n}\n\n/**\n * Returns 5th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component5(): T {\n    return get(4)\n}\n\n/**\n * Returns `true` if [element] is found in the collection.\n */\npublic operator fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.contains(element: T): Boolean {\n    if (this is Collection)\n        return contains(element)\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic fun <T> Iterable<T>.elementAt(index: Int): T {\n    if (this is List)\n        return get(index)\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"Collection doesn't contain element at index $index.\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAt(index: Int): T {\n    return get(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\npublic fun <T> Iterable<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    if (this is List)\n        return this.getOrElse(index, defaultValue)\n    if (index < 0)\n        return defaultValue(index)\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\npublic fun <T> Iterable<T>.elementAtOrNull(index: Int): T? {\n    if (this is List)\n        return this.getOrNull(index)\n    if (index < 0)\n        return null\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAtOrNull(index: Int): T? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.find(predicate: (T) -> Boolean): T? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the collection is empty.\n */\npublic fun <T> Iterable<T>.first(): T {\n    when (this) {\n        is List -> return this.first()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the list is empty.\n */\npublic fun <T> List<T>.first(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"List is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> Iterable<T>.first(predicate: (T) -> Boolean): T {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element, or `null` if the collection is empty.\n */\npublic fun <T> Iterable<T>.firstOrNull(): T? {\n    when (this) {\n        is List -> {\n            if (isEmpty())\n                return null\n            else\n                return this[0]\n        }\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * Returns the first element, or `null` if the list is empty.\n */\npublic fun <T> List<T>.firstOrNull(): T? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun <T> Iterable<T>.firstOrNull(predicate: (T) -> Boolean): T? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this list.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.getOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this list.\n */\npublic fun <T> List<T>.getOrNull(index: Int): T? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns first index of [element], or -1 if the collection does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.indexOf(element: T): Int {\n    if (this is List) return this.indexOf(element)\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the list does not contain element.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\npublic fun <@kotlin.internal.OnlyInputTypes T> List<T>.indexOf(element: T): Int {\n    return indexOf(element)\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the collection does not contain such element.\n */\npublic inline fun <T> Iterable<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the list does not contain such element.\n */\npublic inline fun <T> List<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the collection does not contain such element.\n */\npublic inline fun <T> Iterable<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the list does not contain such element.\n */\npublic inline fun <T> List<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        if (predicate(iterator.previous())) {\n            return iterator.nextIndex()\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the collection is empty.\n */\npublic fun <T> Iterable<T>.last(): T {\n    when (this) {\n        is List -> return this.last()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            var last = iterator.next()\n            while (iterator.hasNext())\n                last = iterator.next()\n            return last\n        }\n    }\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the list is empty.\n */\npublic fun <T> List<T>.last(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"List is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> Iterable<T>.last(predicate: (T) -> Boolean): T {\n    var last: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return last as T\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> List<T>.last(predicate: (T) -> Boolean): T {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        val element = iterator.previous()\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"List contains no element matching the predicate.\")\n}\n\n/**\n * Returns last index of [element], or -1 if the collection does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.lastIndexOf(element: T): Int {\n    if (this is List) return this.lastIndexOf(element)\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns last index of [element], or -1 if the list does not contain element.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\npublic fun <@kotlin.internal.OnlyInputTypes T> List<T>.lastIndexOf(element: T): Int {\n    return lastIndexOf(element)\n}\n\n/**\n * Returns the last element, or `null` if the collection is empty.\n */\npublic fun <T> Iterable<T>.lastOrNull(): T? {\n    when (this) {\n        is List -> return if (isEmpty()) null else this[size - 1]\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            var last = iterator.next()\n            while (iterator.hasNext())\n                last = iterator.next()\n            return last\n        }\n    }\n}\n\n/**\n * Returns the last element, or `null` if the list is empty.\n */\npublic fun <T> List<T>.lastOrNull(): T? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun <T> Iterable<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    var last: T? = null\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n        }\n    }\n    return last\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun <T> List<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        val element = iterator.previous()\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns a random element from this collection.\n * \n * @throws NoSuchElementException if this collection is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.random(): T {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this collection using the specified source of randomness.\n * \n * @throws NoSuchElementException if this collection is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Collection<T>.random(random: Random): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"Collection is empty.\")\n    return elementAt(random.nextInt(size))\n}\n\n/**\n * Returns the single element, or throws an exception if the collection is empty or has more than one element.\n */\npublic fun <T> Iterable<T>.single(): T {\n    when (this) {\n        is List -> return this.single()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            val single = iterator.next()\n            if (iterator.hasNext())\n                throw IllegalArgumentException(\"Collection has more than one element.\")\n            return single\n        }\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the list is empty or has more than one element.\n */\npublic fun <T> List<T>.single(): T {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"List is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"List has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun <T> Iterable<T>.single(predicate: (T) -> Boolean): T {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Collection contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as T\n}\n\n/**\n * Returns single element, or `null` if the collection is empty or has more than one element.\n */\npublic fun <T> Iterable<T>.singleOrNull(): T? {\n    when (this) {\n        is List -> return if (size == 1) this[0] else null\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            val single = iterator.next()\n            if (iterator.hasNext())\n                return null\n            return single\n        }\n    }\n}\n\n/**\n * Returns single element, or `null` if the list is empty or has more than one element.\n */\npublic fun <T> List<T>.singleOrNull(): T? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun <T> Iterable<T>.singleOrNull(predicate: (T) -> Boolean): T? {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Iterable<T>.drop(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return toList()\n    val list: ArrayList<T>\n    if (this is Collection<*>) {\n        val resultSize = size - n\n        if (resultSize <= 0)\n            return emptyList()\n        if (resultSize == 1)\n            return listOf(last())\n        list = ArrayList<T>(resultSize)\n        if (this is List<T>) {\n            if (this is RandomAccess) {\n                for (index in n until size)\n                    list.add(this[index])\n            } else {\n                for (item in listIterator(n))\n                    list.add(item)\n            }\n            return list\n        }\n    }\n    else {\n        list = ArrayList<T>()\n    }\n    var count = 0\n    for (item in this) {\n        if (count >= n) list.add(item) else ++count\n    }\n    return list.optimizeReadOnlyList()\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> List<T>.dropLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> List<T>.dropLastWhile(predicate: (T) -> Boolean): List<T> {\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            if (!predicate(iterator.previous())) {\n                return take(iterator.nextIndex() + 1)\n            }\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> Iterable<T>.dropWhile(predicate: (T) -> Boolean): List<T> {\n    var yielding = false\n    val list = ArrayList<T>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n */\npublic inline fun <T> Iterable<T>.filter(predicate: (T) -> Boolean): List<T> {\n    return filterTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <T> Iterable<T>.filterIndexed(predicate: (index: Int, T) -> Boolean): List<T> {\n    return filterIndexedTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterIndexedTo(destination: C, predicate: (index: Int, T) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Returns a list containing all elements that are instances of specified type parameter R.\n */\npublic inline fun <reified R> Iterable<*>.filterIsInstance(): List<@kotlin.internal.NoInfer R> {\n    return filterIsInstanceTo(ArrayList<R>())\n}\n\n/**\n * Appends all elements that are instances of specified type parameter R to the given [destination].\n */\npublic inline fun <reified R, C : MutableCollection<in R>> Iterable<*>.filterIsInstanceTo(destination: C): C {\n    for (element in this) if (element is R) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n */\npublic inline fun <T> Iterable<T>.filterNot(predicate: (T) -> Boolean): List<T> {\n    return filterNotTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing all elements that are not `null`.\n */\npublic fun <T : Any> Iterable<T?>.filterNotNull(): List<T> {\n    return filterNotNullTo(ArrayList<T>())\n}\n\n/**\n * Appends all elements that are not `null` to the given [destination].\n */\npublic fun <C : MutableCollection<in T>, T : Any> Iterable<T?>.filterNotNullTo(destination: C): C {\n    for (element in this) if (element != null) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterNotTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun <T> List<T>.slice(indices: IntRange): List<T> {\n    if (indices.isEmpty()) return listOf()\n    return this.subList(indices.start, indices.endInclusive + 1).toList()\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun <T> List<T>.slice(indices: Iterable<Int>): List<T> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<T>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Iterable<T>.take(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (this is Collection<T>) {\n        if (n >= size) return toList()\n        if (n == 1) return listOf(first())\n    }\n    var count = 0\n    val list = ArrayList<T>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list.optimizeReadOnlyList()\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> List<T>.takeLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(last())\n    val list = ArrayList<T>(n)\n    if (this is RandomAccess) {\n        for (index in size - n until size)\n            list.add(this[index])\n    } else {\n        for (item in listIterator(size - n))\n            list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> List<T>.takeLastWhile(predicate: (T) -> Boolean): List<T> {\n    if (isEmpty())\n        return emptyList()\n    val iterator = listIterator(size)\n    while (iterator.hasPrevious()) {\n        if (!predicate(iterator.previous())) {\n            iterator.next()\n            val expectedSize = size - iterator.nextIndex()\n            if (expectedSize == 0) return emptyList()\n            return ArrayList<T>(expectedSize).apply {\n                while (iterator.hasNext())\n                    add(iterator.next())\n            }\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> Iterable<T>.takeWhile(predicate: (T) -> Boolean): List<T> {\n    val list = ArrayList<T>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Reverses elements in the list in-place.\n */\npublic expect fun <T> MutableList<T>.reverse(): Unit\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun <T> Iterable<T>.reversed(): List<T> {\n    if (this is Collection && size <= 1) return toList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Sorts elements in the list in-place according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> MutableList<T>.sortBy(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareBy(selector))\n}\n\n/**\n * Sorts elements in the list in-place descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> MutableList<T>.sortByDescending(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareByDescending(selector))\n}\n\n/**\n * Sorts elements in the list in-place descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> MutableList<T>.sortDescending(): Unit {\n    sortWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Iterable<T>.sorted(): List<T> {\n    if (this is Collection) {\n        if (size <= 1) return this.toList()\n        @Suppress(\"UNCHECKED_CAST\")\n        return (toTypedArray<Comparable<T>>() as Array<T>).apply { sort() }.asList()\n    }\n    return toMutableList().apply { sort() }\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.sortedBy(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.sortedByDescending(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Iterable<T>.sortedDescending(): List<T> {\n    return sortedWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T> Iterable<T>.sortedWith(comparator: Comparator<in T>): List<T> {\n    if (this is Collection) {\n       if (size <= 1) return this.toList()\n       @Suppress(\"UNCHECKED_CAST\")\n       return (toTypedArray<Any?>() as Array<T>).apply { sortWith(comparator) }.asList()\n    }\n    return toMutableList().apply { sortWith(comparator) }\n}\n\n/**\n * Returns an array of Boolean containing all of the elements of this collection.\n */\npublic fun Collection<Boolean>.toBooleanArray(): BooleanArray {\n    val result = BooleanArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Byte containing all of the elements of this collection.\n */\npublic fun Collection<Byte>.toByteArray(): ByteArray {\n    val result = ByteArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Char containing all of the elements of this collection.\n */\npublic fun Collection<Char>.toCharArray(): CharArray {\n    val result = CharArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Double containing all of the elements of this collection.\n */\npublic fun Collection<Double>.toDoubleArray(): DoubleArray {\n    val result = DoubleArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Float containing all of the elements of this collection.\n */\npublic fun Collection<Float>.toFloatArray(): FloatArray {\n    val result = FloatArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Int containing all of the elements of this collection.\n */\npublic fun Collection<Int>.toIntArray(): IntArray {\n    val result = IntArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Long containing all of the elements of this collection.\n */\npublic fun Collection<Long>.toLongArray(): LongArray {\n    val result = LongArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Short containing all of the elements of this collection.\n */\npublic fun Collection<Short>.toShortArray(): ShortArray {\n    val result = ShortArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given collection.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n */\npublic inline fun <T, K, V> Iterable<T>.associate(transform: (T) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing the elements from the given collection indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n */\npublic inline fun <T, K> Iterable<T>.associateBy(keySelector: (T) -> K): Map<K, T> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, T>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given collection.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n */\npublic inline fun <T, K, V> Iterable<T>.associateBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, V> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given collection\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <T, K, M : MutableMap<in K, in T>> Iterable<T>.associateByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given collection.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Iterable<T>.associateByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given collection.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Iterable<T>.associateTo(destination: M, transform: (T) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Returns a [Map] where keys are elements from the given collection and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V> Iterable<K>.associateWith(valueSelector: (K) -> V): Map<K, V> {\n    val result = LinkedHashMap<K, V>(mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given collection,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V, M : MutableMap<in K, in V>> Iterable<K>.associateWithTo(destination: M, valueSelector: (K) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <T, C : MutableCollection<in T>> Iterable<T>.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a [HashSet] of all elements.\n */\npublic fun <T> Iterable<T>.toHashSet(): HashSet<T> {\n    return toCollection(HashSet<T>(mapCapacity(collectionSizeOrDefault(12))))\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun <T> Iterable<T>.toList(): List<T> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptyList()\n            1 -> listOf(if (this is List) get(0) else iterator().next())\n            else -> this.toMutableList()\n        }\n    }\n    return this.toMutableList().optimizeReadOnlyList()\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this collection.\n */\npublic fun <T> Iterable<T>.toMutableList(): MutableList<T> {\n    if (this is Collection<T>)\n        return this.toMutableList()\n    return toCollection(ArrayList<T>())\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this collection.\n */\npublic fun <T> Collection<T>.toMutableList(): MutableList<T> {\n    return ArrayList(this)\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic fun <T> Iterable<T>.toSet(): Set<T> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptySet()\n            1 -> setOf(if (this is List) this[0] else iterator().next())\n            else -> toCollection(LinkedHashSet<T>(mapCapacity(size)))\n        }\n    }\n    return toCollection(LinkedHashSet<T>()).optimizeReadOnlySet()\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original collection.\n */\npublic inline fun <T, R> Iterable<T>.flatMap(transform: (T) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original collection, to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapTo(destination: C, transform: (T) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original collection by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original collection.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K> Iterable<T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> {\n    return groupByTo(LinkedHashMap<K, MutableList<T>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original collection\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original collection.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V> Iterable<T>.groupBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups elements of the original collection by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K, M : MutableMap<in K, MutableList<T>>> Iterable<T>.groupByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<T>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original collection\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V, M : MutableMap<in K, MutableList<V>>> Iterable<T>.groupByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from a collection to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each element.\n * \n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K> Iterable<T>.groupingBy(crossinline keySelector: (T) -> K): Grouping<T, K> {\n    return object : Grouping<T, K> {\n        override fun sourceIterator(): Iterator<T> = this@groupingBy.iterator()\n        override fun keyOf(element: T): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original collection.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <T, R> Iterable<T>.map(transform: (T) -> R): List<R> {\n    return mapTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original collection.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R> Iterable<T>.mapIndexed(transform: (index: Int, T) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element and its index in the original collection.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any> Iterable<T>.mapIndexedNotNull(transform: (index: Int, T) -> R?): List<R> {\n    return mapIndexedNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original collection\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Iterable<T>.mapIndexedNotNullTo(destination: C, transform: (index: Int, T) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original collection\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.mapIndexedTo(destination: C, transform: (index: Int, T) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(checkIndexOverflow(index++), item))\n    return destination\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element in the original collection.\n */\npublic inline fun <T, R : Any> Iterable<T>.mapNotNull(transform: (T) -> R?): List<R> {\n    return mapNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element in the original collection\n * and appends only the non-null results to the given [destination].\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Iterable<T>.mapNotNullTo(destination: C, transform: (T) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original collection\n * and appends the results to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.mapTo(destination: C, transform: (T) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original collection\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun <T> Iterable<T>.withIndex(): Iterable<IndexedValue<T>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a list containing only distinct elements from the given collection.\n * \n * The elements in the resulting list are in the same order as they were in the source collection.\n */\npublic fun <T> Iterable<T>.distinct(): List<T> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only elements from the given collection\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source collection.\n */\npublic inline fun <T, K> Iterable<T>.distinctBy(selector: (T) -> K): List<T> {\n    val set = HashSet<K>()\n    val list = ArrayList<T>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a set containing all elements that are contained by both this collection and the specified collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun <T> Iterable<T>.intersect(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this collection and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic infix fun <T> Iterable<T>.subtract(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a mutable set containing all distinct elements from the given collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic fun <T> Iterable<T>.toMutableSet(): MutableSet<T> {\n    return when (this) {\n        is Collection<T> -> LinkedHashSet(this)\n        else -> toCollection(LinkedHashSet<T>())\n    }\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original collection.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun <T> Iterable<T>.union(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun <T> Iterable<T>.all(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return true\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if collection has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun <T> Iterable<T>.any(): Boolean {\n    if (this is Collection) return !isEmpty()\n    return iterator().hasNext()\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun <T> Iterable<T>.any(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return false\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of elements in this collection.\n */\npublic fun <T> Iterable<T>.count(): Int {\n    if (this is Collection) return size\n    var count = 0\n    for (element in this) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Returns the number of elements in this collection.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun <T> Iterable<T>.count(predicate: (T) -> Boolean): Int {\n    if (this is Collection && isEmpty()) return 0\n    var count = 0\n    for (element in this) if (predicate(element)) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <T, R> Iterable<T>.fold(initial: R, operation: (acc: R, T) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Iterable<T>.foldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(checkIndexOverflow(index++), accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <T, R> List<T>.foldRight(initial: R, operation: (T, acc: R) -> R): R {\n    var accumulator = initial\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            accumulator = operation(iterator.previous(), accumulator)\n        }\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <T, R> List<T>.foldRightIndexed(initial: R, operation: (index: Int, T, acc: R) -> R): R {\n    var accumulator = initial\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            val index = iterator.previousIndex()\n            accumulator = operation(index, iterator.previous(), accumulator)\n        }\n    }\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each element.\n */\n@kotlin.internal.HidesMembers\npublic inline fun <T> Iterable<T>.forEach(action: (T) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the desired action on the element.\n */\npublic inline fun <T> Iterable<T>.forEachIndexed(action: (index: Int, T) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(checkIndexOverflow(index++), item)\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Double>.max(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    if (max.isNaN()) return max\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Float>.max(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    if (max.isNaN()) return max\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\npublic fun <T : Comparable<T>> Iterable<T>.max(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxBy(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxElem = iterator.next()\n    if (!iterator.hasNext()) return maxElem\n    var maxValue = selector(maxElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    } while (iterator.hasNext())\n    return maxElem\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun <T> Iterable<T>.maxWith(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Double>.min(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    if (min.isNaN()) return min\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Float>.min(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    if (min.isNaN()) return min\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\npublic fun <T : Comparable<T>> Iterable<T>.min(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minBy(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minElem = iterator.next()\n    if (!iterator.hasNext()) return minElem\n    var minValue = selector(minElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    } while (iterator.hasNext())\n    return minElem\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun <T> Iterable<T>.minWith(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the collection has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun <T> Iterable<T>.none(): Boolean {\n    if (this is Collection) return isEmpty()\n    return !iterator().hasNext()\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun <T> Iterable<T>.none(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return true\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Performs the given [action] on each element and returns the collection itself afterwards.\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, C : Iterable<T>> C.onEach(action: (T) -> Unit): C {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <S, T : S> Iterable<T>.reduce(operation: (acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty collection can't be reduced.\")\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself and calculates the next accumulator value.\n */\npublic inline fun <S, T : S> Iterable<T>.reduceIndexed(operation: (index: Int, acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty collection can't be reduced.\")\n    var index = 1\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <S, T : S> List<T>.reduceRight(operation: (T, acc: S) -> S): S {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        throw UnsupportedOperationException(\"Empty list can't be reduced.\")\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        accumulator = operation(iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <S, T : S> List<T>.reduceRightIndexed(operation: (index: Int, T, acc: S) -> S): S {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        throw UnsupportedOperationException(\"Empty list can't be reduced.\")\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        val index = iterator.previousIndex()\n        accumulator = operation(index, iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\npublic inline fun <T> Iterable<T>.sumBy(selector: (T) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\npublic inline fun <T> Iterable<T>.sumByDouble(selector: (T) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> Iterable<T?>.requireNoNulls(): Iterable<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as Iterable<T>\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> List<T?>.requireNoNulls(): List<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as List<T>\n}\n\n/**\n * Splits this collection into a list of lists each not exceeding the given [size].\n * \n * The last list in the resulting list may have less elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this collection.\n * \n * @sample samples.collections.Collections.Transformations.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.chunked(size: Int): List<List<T>> {\n    return windowed(size, size, partialWindows = true)\n}\n\n/**\n * Splits this collection into several lists each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return list of results of the [transform] applied to an each list.\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last list may have less elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this collection.\n * \n * @sample samples.text.Strings.chunkedTransform\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Iterable<T>.chunked(size: Int, transform: (List<T>) -> R): List<R> {\n    return windowed(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Returns a list containing all elements of the original collection without the first occurrence of the given [element].\n */\npublic operator fun <T> Iterable<T>.minus(element: T): List<T> {\n    val result = ArrayList<T>(collectionSizeOrDefault(10))\n    var removed = false\n    return this.filterTo(result) { if (!removed && it == element) { removed = true; false } else true }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] array.\n * \n * The [elements] array may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Array<out T>): List<T> {\n    if (elements.isEmpty()) return this.toList()\n    val other = elements.toHashSet()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] collection.\n * \n * The [elements] collection may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Iterable<T>): List<T> {\n    val other = elements.convertToSetForSetOperationWith(this)\n    if (other.isEmpty())\n        return this.toList()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] sequence.\n * \n * The [elements] sequence may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Sequence<T>): List<T> {\n    val other = elements.toHashSet()\n    if (other.isEmpty())\n        return this.toList()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection without the first occurrence of the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minusElement(element: T): List<T> {\n    return minus(element)\n}\n\n/**\n * Splits the original collection into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n */\npublic inline fun <T> Iterable<T>.partition(predicate: (T) -> Boolean): Pair<List<T>, List<T>> {\n    val first = ArrayList<T>()\n    val second = ArrayList<T>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\npublic operator fun <T> Iterable<T>.plus(element: T): List<T> {\n    if (this is Collection) return this.plus(element)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.add(element)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\npublic operator fun <T> Collection<T>.plus(element: T): List<T> {\n    val result = ArrayList<T>(size + 1)\n    result.addAll(this)\n    result.add(element)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] array.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Array<out T>): List<T> {\n    if (this is Collection) return this.plus(elements)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] array.\n */\npublic operator fun <T> Collection<T>.plus(elements: Array<out T>): List<T> {\n    val result = ArrayList<T>(this.size + elements.size)\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Iterable<T>): List<T> {\n    if (this is Collection) return this.plus(elements)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection.\n */\npublic operator fun <T> Collection<T>.plus(elements: Iterable<T>): List<T> {\n    if (elements is Collection) {\n        val result = ArrayList<T>(this.size + elements.size)\n        result.addAll(this)\n        result.addAll(elements)\n        return result\n    } else {\n        val result = ArrayList<T>(this)\n        result.addAll(elements)\n        return result\n    }\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Sequence<T>): List<T> {\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence.\n */\npublic operator fun <T> Collection<T>.plus(elements: Sequence<T>): List<T> {\n    val result = ArrayList<T>(this.size + 10)\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.plusElement(element: T): List<T> {\n    return plus(element)\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.plusElement(element: T): List<T> {\n    return plus(element)\n}\n\n/**\n * Returns a list of snapshots of the window of the given [size]\n * sliding along this collection with the given [step], where each\n * snapshot is a list.\n * \n * Several last lists may have less elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this collection.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false): List<List<T>> {\n    checkWindowSizeStep(size, step)\n    if (this is RandomAccess && this is List) {\n        val thisSize = this.size\n        val resultCapacity = thisSize / step + if (thisSize % step == 0) 0 else 1\n        val result = ArrayList<List<T>>(resultCapacity)\n        var index = 0\n        while (index in 0 until thisSize) {\n            val windowSize = size.coerceAtMost(thisSize - index)\n            if (windowSize < size && !partialWindows) break\n            result.add(List(windowSize) { this[it + index] })\n            index += step\n        }\n        return result\n    }\n    val result = ArrayList<List<T>>()\n    windowedIterator(iterator(), size, step, partialWindows, reuseBuffer = false).forEach {\n        result.add(it)\n    }\n    return result\n}\n\n/**\n * Returns a list of results of applying the given [transform] function to\n * an each list representing a view over the window of the given [size]\n * sliding along this collection with the given [step].\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last lists may have less elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this collection.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Iterable<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (List<T>) -> R): List<R> {\n    checkWindowSizeStep(size, step)\n    if (this is RandomAccess && this is List) {\n        val thisSize = this.size\n        val resultCapacity = thisSize / step + if (thisSize % step == 0) 0 else 1\n        val result = ArrayList<R>(resultCapacity)\n        val window = MovingSubList(this)\n        var index = 0\n        while (index in 0 until thisSize) {\n            val windowSize = size.coerceAtMost(thisSize - index)\n            if (!partialWindows && windowSize < size) break\n            window.move(index, index + windowSize)\n            result.add(transform(window))\n            index += step\n        }\n        return result\n    }\n    val result = ArrayList<R>()\n    windowedIterator(iterator(), size, step, partialWindows, reuseBuffer = true).forEach {\n        result.add(transform(it))\n    }\n    return result\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Iterable<T>.zip(other: Array<out R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` collection and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Iterable<T>.zip(other: Array<out R>, transform: (a: T, b: R) -> V): List<V> {\n    val arraySize = other.size\n    val list = ArrayList<V>(minOf(collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in this) {\n        if (i >= arraySize) break\n        list.add(transform(element, other[i++]))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] collection with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Iterable<T>.zip(other: Iterable<R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` collection and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Iterable<T>.zip(other: Iterable<R>, transform: (a: T, b: R) -> V): List<V> {\n    val first = iterator()\n    val second = other.iterator()\n    val list = ArrayList<V>(minOf(collectionSizeOrDefault(10), other.collectionSizeOrDefault(10)))\n    while (first.hasNext() && second.hasNext()) {\n        list.add(transform(first.next(), second.next()))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs of each two adjacent elements in this collection.\n * \n * The returned list is empty if this collection contains less than two elements.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNext\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.zipWithNext(): List<Pair<T, T>> {\n    return zipWithNext { a, b -> a to b }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to an each pair of two adjacent elements in this collection.\n * \n * The returned list is empty if this collection contains less than two elements.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNextToFindDeltas\n */\n@SinceKotlin(\"1.2\")\npublic inline fun <T, R> Iterable<T>.zipWithNext(transform: (a: T, b: T) -> R): List<R> {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return emptyList()\n    val result = mutableListOf<R>()\n    var current = iterator.next()\n    while (iterator.hasNext()) {\n        val next = iterator.next()\n        result.add(transform(current, next))\n        current = next\n    }\n    return result\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <T, A : Appendable> Iterable<T>.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            buffer.appendElement(element, transform)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun <T> Iterable<T>.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Returns this collection as an [Iterable].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.asIterable(): Iterable<T> {\n    return this\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original collection returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromCollection\n */\npublic fun <T> Iterable<T>.asSequence(): Sequence<T> {\n    return Sequence { this.iterator() }\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfByte\")\npublic fun Iterable<Byte>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfShort\")\npublic fun Iterable<Short>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfInt\")\npublic fun Iterable<Int>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfLong\")\npublic fun Iterable<Long>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfFloat\")\npublic fun Iterable<Float>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfDouble\")\npublic fun Iterable<Double>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfByte\")\npublic fun Iterable<Byte>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfShort\")\npublic fun Iterable<Short>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfInt\")\npublic fun Iterable<Int>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfLong\")\npublic fun Iterable<Long>.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfFloat\")\npublic fun Iterable<Float>.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfDouble\")\npublic fun Iterable<Double>.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n",null,"/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StandardKt\")\npackage kotlin\n\nimport kotlin.contracts.*\n\n/**\n * An exception is thrown to indicate that a method body remains to be implemented.\n */\npublic class NotImplementedError(message: String = \"An operation is not implemented.\") : Error(message)\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n */\n\n@kotlin.internal.InlineOnly\npublic inline fun TODO(): Nothing = throw NotImplementedError()\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n *\n * @param reason a string explaining why the implementation is missing.\n */\n@kotlin.internal.InlineOnly\npublic inline fun TODO(reason: String): Nothing = throw NotImplementedError(\"An operation is not implemented: $reason\")\n\n\n\n/**\n * Calls the specified function [block] and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <R> run(block: () -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.run(block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with the given [receiver] as its receiver and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#with).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> with(receiver: T, block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return receiver.block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns `this` value.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#apply).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> T.apply(block: T.() -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block()\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns `this` value.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#also).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.also(block: (T) -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block(this)\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#let).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.let(block: (T) -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block(this)\n}\n\n/**\n * Returns `this` value if it satisfies the given [predicate] or `null`, if it doesn't.\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeIf(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (predicate(this)) this else null\n}\n\n/**\n * Returns `this` value if it _does not_ satisfy the given [predicate] or `null`, if it does.\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeUnless(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (!predicate(this)) this else null\n}\n\n/**\n * Executes the given function [action] specified number of [times].\n *\n * A zero-based index of current iteration is passed as a parameter to [action].\n *\n * @sample samples.misc.ControlFlow.repeat\n */\n@kotlin.internal.InlineOnly\npublic inline fun repeat(times: Int, action: (Int) -> Unit) {\n    contract { callsInPlace(action) }\n\n    for (index in 0 until times) {\n        action(index)\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\nimport kotlin.js.RegExp\n\n/**\n * Converts the characters in the specified array to a string.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun String(chars: CharArray): String {\n    var result = \"\"\n    for (char in chars) {\n        result += char\n    }\n    return result\n}\n\n/**\n * Converts the characters from a portion of the specified array to a string.\n *\n * @throws IndexOutOfBoundsException if either [offset] or [length] are less than zero\n * or `offset + length` is out of [chars] array bounds.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun String(chars: CharArray, offset: Int, length: Int): String {\n    if (offset < 0 || length < 0 || chars.size - offset < length)\n        throw IndexOutOfBoundsException(\"size: ${chars.size}; offset: $offset; length: $length\")\n    var result = \"\"\n    for (index in offset until offset + length) {\n        result += chars[index]\n    }\n    return result\n}\n\n/**\n * Concatenates characters in this [CharArray] into a String.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic actual fun CharArray.concatToString(): String {\n    var result = \"\"\n    for (char in this) {\n        result += char\n    }\n    return result\n}\n\n/**\n * Concatenates characters in this [CharArray] or its subrange into a String.\n *\n * @param startIndex the beginning (inclusive) of the subrange of characters, 0 by default.\n * @param endIndex the end (exclusive) of the subrange of characters, size of this array by default.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\n@ExperimentalStdlibApi\npublic actual fun CharArray.concatToString(startIndex: Int = 0, endIndex: Int = this.size): String {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, this.size)\n    var result = \"\"\n    for (index in startIndex until endIndex) {\n        result += this[index]\n    }\n    return result\n}\n\n/**\n * Returns a [CharArray] containing characters of this string.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic actual fun String.toCharArray(): CharArray {\n    return CharArray(length) { get(it) }\n}\n\n/**\n * Returns a [CharArray] containing characters of this string or its substring.\n *\n * @param startIndex the beginning (inclusive) of the substring, 0 by default.\n * @param endIndex the end (exclusive) of the substring, length of this string by default.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the length of this string.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\n@ExperimentalStdlibApi\npublic actual fun String.toCharArray(startIndex: Int = 0, endIndex: Int = this.length): CharArray {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, length)\n    return CharArray(endIndex - startIndex) { get(startIndex + it) }\n}\n\n/**\n * Decodes a string from the bytes in UTF-8 encoding in this array.\n *\n * Malformed byte sequences are replaced by the replacement char `\\uFFFD`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic actual fun ByteArray.decodeToString(): String {\n    return decodeUtf8(this, 0, size, false)\n}\n\n/**\n * Decodes a string from the bytes in UTF-8 encoding in this array or its subrange.\n *\n * @param startIndex the beginning (inclusive) of the subrange to decode, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to decode, size of this array by default.\n * @param throwOnInvalidSequence specifies whether to throw an exception on malformed byte sequence or replace it by the replacement char `\\uFFFD`.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n * @throws CharacterCodingException if the byte array contains malformed UTF-8 byte sequence and [throwOnInvalidSequence] is true.\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\n@ExperimentalStdlibApi\npublic actual fun ByteArray.decodeToString(\n    startIndex: Int = 0,\n    endIndex: Int = this.size,\n    throwOnInvalidSequence: Boolean = false\n): String {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, this.size)\n    return decodeUtf8(this, startIndex, endIndex, throwOnInvalidSequence)\n}\n\n/**\n * Encodes this string to an array of bytes in UTF-8 encoding.\n *\n * Any malformed char sequence is replaced by the replacement byte sequence.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic actual fun String.encodeToByteArray(): ByteArray {\n    return encodeUtf8(this, 0, length, false)\n}\n\n/**\n * Encodes this string or its substring to an array of bytes in UTF-8 encoding.\n *\n * @param startIndex the beginning (inclusive) of the substring to encode, 0 by default.\n * @param endIndex the end (exclusive) of the substring to encode, length of this string by default.\n * @param throwOnInvalidSequence specifies whether to throw an exception on malformed char sequence or replace.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the length of this string.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n * @throws CharacterCodingException if this string contains malformed char sequence and [throwOnInvalidSequence] is true.\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\n@ExperimentalStdlibApi\npublic actual fun String.encodeToByteArray(\n    startIndex: Int = 0,\n    endIndex: Int = this.length,\n    throwOnInvalidSequence: Boolean = false\n): ByteArray {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, length)\n    return encodeUtf8(this, startIndex, endIndex, throwOnInvalidSequence)\n}\n\n/**\n * Returns a copy of this string converted to upper case using the rules of the default locale.\n *\n * @sample samples.text.Strings.toUpperCase\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toUpperCase(): String = asDynamic().toUpperCase()\n\n/**\n * Returns a copy of this string converted to lower case using the rules of the default locale.\n *\n * @sample samples.text.Strings.toLowerCase\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toLowerCase(): String = asDynamic().toLowerCase()\n\n@kotlin.internal.InlineOnly\ninternal actual inline fun String.nativeIndexOf(str: String, fromIndex: Int): Int = asDynamic().indexOf(str, fromIndex)\n\n@kotlin.internal.InlineOnly\ninternal actual inline fun String.nativeLastIndexOf(str: String, fromIndex: Int): Int = asDynamic().lastIndexOf(str, fromIndex)\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeStartsWith(s: String, position: Int): Boolean = asDynamic().startsWith(s, position)\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeEndsWith(s: String): Boolean = asDynamic().endsWith(s)\n\n@kotlin.internal.InlineOnly\npublic actual inline fun String.substring(startIndex: Int): String = asDynamic().substring(startIndex)\n\n@kotlin.internal.InlineOnly\npublic actual inline fun String.substring(startIndex: Int, endIndex: Int): String = asDynamic().substring(startIndex, endIndex)\n\n@kotlin.internal.InlineOnly\npublic inline fun String.concat(str: String): String = asDynamic().concat(str)\n\n@kotlin.internal.InlineOnly\npublic inline fun String.match(regex: String): Array<String>? = asDynamic().match(regex)\n\n//native public fun String.trim(): String\n//TODO: String.replace to implement effective trimLeading and trimTrailing\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeReplace(pattern: RegExp, replacement: String): String = asDynamic().replace(pattern, replacement)\n\n@SinceKotlin(\"1.2\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.compareTo(other: String, ignoreCase: Boolean = false): Int {\n    if (ignoreCase) {\n        val n1 = this.length\n        val n2 = other.length\n        val min = minOf(n1, n2)\n        if (min == 0) return n1 - n2\n        var start = 0\n        while (true) {\n            val end = minOf(start + 16, min)\n            var s1 = this.substring(start, end)\n            var s2 = other.substring(start, end)\n            if (s1 != s2) {\n                s1 = s1.toUpperCase()\n                s2 = s2.toUpperCase()\n                if (s1 != s2) {\n                    s1 = s1.toLowerCase()\n                    s2 = s2.toLowerCase()\n                    if (s1 != s2) {\n                        return s1.compareTo(s2)\n                    }\n                }\n            }\n            if (end == min) break\n            start = end\n        }\n        return n1 - n2\n    } else {\n        return compareTo(other)\n    }\n}\n\n\nprivate val STRING_CASE_INSENSITIVE_ORDER = Comparator<String> { a, b -> a.compareTo(b, ignoreCase = true) }\n\n@SinceKotlin(\"1.2\")\npublic actual val String.Companion.CASE_INSENSITIVE_ORDER: Comparator<String>\n    get() = STRING_CASE_INSENSITIVE_ORDER\n",null],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;wBA2GA,4D;oBAAA,2C;4BAAA,iB;4BC7BA,gE;mBCqTA,kE;0BAAA,4D;oBAAA,2C;iBDvTA,qD;iBD0GA,wC;yBAAA,c;kBAgYA,yC;0BAAA,e;;;;;;gCGmuBA,yD;uBAAA,gD;EF1sCwC,gD;IAAA,4B;MAAE,wB;MAAQ,W;K;G;EAHuB,qC;IAAA,4B;MAAE,wB;MAAQ,W;K;G;EAG3C,kD;IAAA,4B;MAAE,wB;MAAQ,W;K;G;EAAV,kD;IAAA,4B;MAAE,wB;MAAQ,W;K;G;EG7DlD,gB;IAEI,U;IACA,U;G;;;;;EAmBmB,yD;IACH,kBAAK,OAAL,C;IACA,kBAAQ,K;IACR,mBAAS,K;IACb,W;G;EACO,2D;IACH,kBAAK,SAAL,C;IACA,qBAAQ,gBAAR,C;IACA,4BAAC,SAAD,C;IACJ,W;G;EAXA,8C;IAAA,4B;MACA,qBAAQ,4CAAR,C;MACA,uB;MJuE8H,Q;MAAA,cAAgD,OChCpL,oBDgCoI,gBAAO,gBAAgB,OAAhB,EAA/E,IAA+E,CAAP,EAA0C,WAA1C,CChCpI,EDgCqM,WChCrM,EAA8B,wBGvCjB,oCHuCiB,CAA9B,CDgCoI,0C;MCnC9E,SC2TsM,gBAAO,mBAAgB,aAAhB,EAArL,IAAoN,sBAApN,IAAoN,QAA/B,EAAyD,YAAzD,EAA9I,IAAqN,sBAArN,IAAqN,QAAvE,EAAgG,MAAhG,EAAvH,IAAuH,EAA6G,MAA7G,EAA5F,IAAiN,sBAAjN,IAAiN,QAArH,EAAwI,OAAxI,EAAlE,IAAkE,EAAP,EAAkK,kBAAlK,CD3TtM,EAAS,aG/BlD,sCH+BkD,CAAT,C;MG1BpD,W;K;G;EAIW,2D;IACH,kBAAK,QAAL,C;IACA,kBAAQ,K;IACR,mBAAS,K;IACb,W;G;EANA,gD;IAAA,4B;MACA,qBAAQ,4CAAR,C;MACA,uB;MJyD8H,Q;MAAA,cAAgD,OChCpL,oBDgCoI,gBAAO,gBAAgB,OAAhB,EAA/E,IAA+E,CAAP,EAA0C,WAA1C,CChCpI,EDgCqM,WChCrM,EAA8B,wBGzBjB,sCHyBiB,CAA9B,CDgCoI,0C;MIpDlI,W;K;G;EAEI,oD;IACA,kBAAK,kBAAL,C;IACA,qBAAQ,4CAAR,C;IACJ,W;G;EA5BC,uC;IAAA,4B;MACD,qBAAQ,+FAAR,C;MACA,uB;MAAA,YAAI,oC;MJoJqH,Q;MAAA,cAA6C,OC3GxK,oBD2G2H,aAAI,gBAAgB,OAAhB,EAAtE,IAAsE,CAAJ,EAAuC,WAAvC,CC3G3H,ED2GyL,WC3GzL,EAA8B,0BD2GiK,KC3GjK,CAA9B,CD2G2H,uC;MIvIzH,4BAAC,GAAD,C;MACA,uB;MAAA,cAAI,sC;MJsIqH,U;MAAA,cAA6C,SC3GxK,oBD2G2H,aAAI,gBAAgB,OAAhB,EAAtE,IAAsE,CAAJ,EAAuC,WAAvC,CC3G3H,ED2GyL,WC3GzL,EAA8B,0BD2GiK,OC3GjK,CAA9B,CD2G2H,yC;MI9HzH,4BAAC,GAAD,C;MACA,uB;MJ6HyH,U;MAAA,cAA6C,SC3GxK,oBD2G2H,aAAI,gBAAgB,OAAhB,EAAtE,IAAsE,CAAJ,EAAuC,WAAvC,CC3G3H,ED2GyL,WC3GzL,EAA8B,0BGlBxB,+BHkBwB,CAA9B,CD2G2H,yC;MIzH7H,W;K;G;EA9BmB,oC;IJuhB6G,Q;IAAA,cAA8C,OC3e5K,oBD2e8H,cAAK,gBAAgB,OAAhB,EAAzE,IAAyE,CAAL,YC3e9H,aAA8B,0BG3C3B,iCH2C2B,CAA9B,CD2e8H,wC;IIxfpI,W;G;EArCJ,oB;IAC0B,gBAAtB,cAAA,QAAS,KAAT,CAAgB,M;ICoDhB,SDnDI,mBAAkB,6D;ICmDtB,SDlDI,oBAAmB,W;ICkDvB,SDjDI,kBAAiB,W;IAEL,OAAhB,cAAA,QAAS,KAAT,CAAgB,EAAO,eAAP,C;G;EAuCE,2D;IAAA,mB;MACd,kBAAW,O;MACX,kBAAW,aAAI,aAAS,eAAT,EAAsB,uBAAtB,CAAJ,EAAgD,YAAhD,C;MACf,W;K;G;EAEoB,gC;IAChB,QAAM,GAAN,C;WACI,W;QADJ,OACoB,M;WAChB,Y;QAFJ,OAEoB,O;WAChB,S;QAHJ,OAGoB,I;WAChB,W;QAJJ,OAIoB,M;WAChB,G;QALJ,OAKoB,O;WAChB,O;QANJ,OAMoB,O;cANpB,OAOoB,G;;G;EAIG,2F;IAAA,qB;MACvB,UAAU,EAAG,IEwF+C,c;MFvF5D,IAAI,YAAO,GAAP,CAAJ,C;QACI,qB;;;QAEA,kBAAW,wBAAe,sBAAc,GAAd,CAAf,C;;MAEnB,W;K;G;EAEyB,sE;IAAA,qB;MACrB,UAAU,EAAG,IE+E+C,c;MF9E5D,kBAAW,0BAAiB,sBAAc,GAAd,CAAjB,C;MACf,W;K;G;EAEqE,gD;IAAA,qB;MACjE,qB;MACJ,W;K;G;EAtCJ,oB;IAsBa,UASA,MATA,EAcC,M;IAlCV,iBAAmC,oB;IACnC,WAAqB,e;IAErB,kBAAkB,iC;IAKlB,oBAAoB,iB;IAYpB,CAAS,OAAT,QAAS,KAAT,8BAA2B,yDAA3B,Q;IASA,CAAS,SAAT,QAAS,KAAT,8BAAyB,4CAAzB,Q;IAKA,CAAC,cAAS,SAAT,QAAS,gBAAe,UAAf,CAAT,0CAAD,YAAqE,8B;IAIrE,UAAW,aAAI,aAAS,eAAT,EAAsB,uBAAtB,CAAJ,EAAgD,IAAhD,C;G;EG/Ff,qB;G;0CACI,iB;IACiB,IAAS,I;IAAtB,aAAa,cAAS,OAAT,QAAS,gBAAe,QAAf,CAAT,wC;IACb,kBAAW,MAAX,C;IACA,kBAAW,MAAX,EAAmB,KAAnB,C;G;qCAGJ,kB;IACc,IAAO,I;IAAjB,UAAU,cAAO,OAAP,MAAO,YAAW,IAAX,CAAP,+C;IACV,gBAAgB,O;IAChB,GAAI,UAAS,GAAT,EAAc,GAAd,EAAmB,MAAa,MAAhC,EAA4C,MAAc,OAA1D,C;G;qCAGR,yB;IACiB,Q;IAAA,uB;IAAb,OAAa,cAAb,C;MAAa,sB;MACT,YAAY,iBAAU,IAAK,MAAf,C;MACZ,iBAAkB,MAAO,MAAP,GAAe,EAAf,I;MAElB,iBAAU,MAAV,EAAkB,IAAK,IAAvB,EAA4B,IAAK,IAAjC,EAAsC,UAAtC,EAAkD,KAAlD,C;;G;8CAIR,iB;IACiB,IAAS,I;IAAtB,aAAa,cAAS,OAAT,QAAS,gBAAe,OAAf,CAAT,wC;IACb,eAAQ,MAAR,EAAgB,KAAhB,C;G;kDAGJ,sB;IACwB,IAAS,IAAT,EAGN,MAHM,EAIa,M;IAJjC,oBAAoB,cAAS,OAAT,QAAS,gBAAe,kBAAf,CAAT,qC;IACN,MAAd,aAAc,C;IAEA,8B;IAAd,OAAc,gBAAd,C;MAAc,yB;MACV,oBAAoB,cAAS,SAAT,QAAS,eAAc,QAAd,CAAT,0C;MAEpB,sBAAsB,G;MACtB,uBAAuB,G;MACvB,aAAc,MAAd,WAA8B,O;MAC9B,eAAQ,aAAR,EAAuB,KAAvB,C;MACA,aAAc,aAAY,aAAZ,C;;G;kCAItB,yB;IACI,0BAAmB,MAAnB,C;IACA,yBAAkB,MAAlB,EAA0B,KAA1B,C;G;6CAGJ,kB;IACc,IAAO,I;IAAjB,UAAU,cAAO,OAAP,MAAO,YAAW,IAAX,CAAP,+C;IACV,gBAAgB,O;IAChB,GAAI,UAAS,GAAT,EAAc,GAAd,EAAmB,MAAa,MAAhC,EAA4C,MAAc,OAA1D,C;G;4CAGR,yB;IAMsB,UACA,MADA,EAEA,MAFA,EAGA,MAHA,EAQL,M;IAbb,uBAAuB,C;IJ4tCpB,kBAAM,eAAa,wBIztCX,KJytCW,EAAwB,EAAxB,CAAb,C;IAqEA,U;IAAA,SI9xCE,KJ8xCF,W;IAAb,OAAa,gBAAb,C;MAAa,wB;MACT,WAAY,WAAc,II/xCA,IJ+xCd,C;;II/xCZ,WJgyCG,W;IAvEA,oBAAM,eAAa,wBIxtCX,KJwtCW,EAAwB,EAAxB,CAAb,C;IAqEA,U;IAAA,SI7xCE,KJ6xCF,W;IAAb,OAAa,gBAAb,C;MAAa,0B;MACT,aAAY,WAAc,MI9xCA,IJ8xCd,C;;II9xCZ,WJ+xCG,a;II9xCH,aAAa,CAAK,WAAL,IAAK,CAAL,mBAAc,C;IAC3B,aAAa,CAAK,aAAL,IAAK,CAAL,qBAAc,gB;IAC3B,aAAa,CAAK,aAAL,IAAK,CAAL,qBAAc,C;IAC3B,aAAa,CAAK,aAAL,IAAK,CAAL,qBAAc,gB;IAC3B,WAAW,UAAS,CAAC,oBAAoB,MAApB,GAA6B,MAA7B,GAAsC,CAAtC,KAAD,IAA6C,CAA7C,IAAT,K;IACX,WAAW,UAAS,CAAC,oBAAoB,MAApB,GAA6B,MAA7B,GAAsC,CAAtC,KAAD,IAA6C,CAA7C,IAAT,K;IACX,iBAAiB,MAAO,MAAP,GAAe,gBAAf,I;IAEJ,yB;IAAb,OAAa,gBAAb,C;MAAa,wB;MACT,YAAY,iBAAU,IAAK,MAAf,C;MACZ,iBAAU,MAAV,EAAkB,IAAK,IAAL,GAAW,IAAX,IAAlB,EAAmC,IAAK,IAAL,GAAW,IAAX,IAAnC,EAAoD,UAApD,EAAgE,KAAhE,C;;G;oCAIR,mD;IACc,IAAO,I;IAAjB,UAAU,cAAO,OAAP,MAAO,YAAW,IAAX,CAAP,+C;IACV,WAAsB,U;IAEtB,gBAAgB,M;IAChB,GAAI,UAAS,MAAM,IAAf,EAAqB,MAAM,IAA3B,EAAiC,IAAjC,EAAuC,IAAvC,C;IAGJ,gBAAgB,S;IAChB,GAAI,UAAS,MAAM,IAAN,GAAa,CAAtB,EAAyB,MAAM,IAAN,GAAa,CAAtC,EAAyC,OAAO,CAAhD,EAAmD,OAAO,CAA1D,C;G;oCAGR,iB;IAAkD,QAAM,KAAN,M;WAC9C,O;QAD8C,OACtB,O;WACxB,K;QAF8C,OAEtB,K;WACxB,W;QAH8C,OAGtB,M;WACxB,Q;QAJ8C,OAItB,Q;WACxB,Y;QAL8C,OAKtB,M;WACxB,Q;QAN8C,OAMtB,Q;WACxB,Q;QAP8C,OAOtB,Q;WACxB,M;QAR8C,OAQtB,M;cARsB,mC;;G;;;;;;;;aH3EjC,O;YACD,M;uBACW,gB;eACR,S;;;;"}